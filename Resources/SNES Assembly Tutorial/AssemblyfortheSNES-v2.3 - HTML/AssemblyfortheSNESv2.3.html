<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_bptz5kijd0at-3{list-style-type:none}ul.lst-kix_bptz5kijd0at-4{list-style-type:none}ul.lst-kix_bptz5kijd0at-5{list-style-type:none}ul.lst-kix_bptz5kijd0at-6{list-style-type:none}ul.lst-kix_bptz5kijd0at-0{list-style-type:none}ul.lst-kix_bptz5kijd0at-1{list-style-type:none}ul.lst-kix_bptz5kijd0at-2{list-style-type:none}.lst-kix_list_3-0>li:before{content:"\0025cf  "}.lst-kix_list_3-1>li:before{content:"\0025cb  "}.lst-kix_list_3-2>li:before{content:"\0025a0  "}.lst-kix_list_3-5>li:before{content:"\0025a0  "}.lst-kix_list_3-4>li:before{content:"\0025cb  "}.lst-kix_ksrdahph672e-2>li:before{content:"-  "}.lst-kix_list_3-3>li:before{content:"\0025cf  "}ul.lst-kix_bptz5kijd0at-7{list-style-type:none}.lst-kix_ksrdahph672e-1>li:before{content:"-  "}ul.lst-kix_bptz5kijd0at-8{list-style-type:none}ul.lst-kix_qwoq0ceavo4-3{list-style-type:none}ul.lst-kix_qwoq0ceavo4-4{list-style-type:none}.lst-kix_list_3-8>li:before{content:"\0025a0  "}ul.lst-kix_qwoq0ceavo4-1{list-style-type:none}ul.lst-kix_qwoq0ceavo4-2{list-style-type:none}ul.lst-kix_qwoq0ceavo4-0{list-style-type:none}.lst-kix_ksrdahph672e-3>li:before{content:"-  "}.lst-kix_list_3-6>li:before{content:"\0025cf  "}ul.lst-kix_ltt0rgoz0br6-7{list-style-type:none}.lst-kix_ksrdahph672e-4>li:before{content:"-  "}ul.lst-kix_ltt0rgoz0br6-8{list-style-type:none}.lst-kix_list_3-7>li:before{content:"\0025cb  "}.lst-kix_ksrdahph672e-5>li:before{content:"-  "}.lst-kix_ksrdahph672e-7>li:before{content:"-  "}.lst-kix_ksrdahph672e-6>li:before{content:"-  "}.lst-kix_ksrdahph672e-8>li:before{content:"-  "}ul.lst-kix_qwoq0ceavo4-7{list-style-type:none}ul.lst-kix_qwoq0ceavo4-8{list-style-type:none}ul.lst-kix_qwoq0ceavo4-5{list-style-type:none}ul.lst-kix_qwoq0ceavo4-6{list-style-type:none}ul.lst-kix_jxdv6vpg8s4z-4{list-style-type:none}ul.lst-kix_jxdv6vpg8s4z-3{list-style-type:none}.lst-kix_bptz5kijd0at-0>li:before{content:"-  "}ul.lst-kix_jxdv6vpg8s4z-2{list-style-type:none}ul.lst-kix_jxdv6vpg8s4z-1{list-style-type:none}ul.lst-kix_jxdv6vpg8s4z-8{list-style-type:none}ul.lst-kix_jxdv6vpg8s4z-7{list-style-type:none}.lst-kix_bptz5kijd0at-1>li:before{content:"-  "}ul.lst-kix_jxdv6vpg8s4z-6{list-style-type:none}ul.lst-kix_jxdv6vpg8s4z-5{list-style-type:none}ul.lst-kix_jxdv6vpg8s4z-0{list-style-type:none}.lst-kix_jxdv6vpg8s4z-3>li:before{content:"-  "}ul.lst-kix_ltt0rgoz0br6-1{list-style-type:none}ul.lst-kix_ltt0rgoz0br6-2{list-style-type:none}.lst-kix_jxdv6vpg8s4z-2>li:before{content:"-  "}.lst-kix_jxdv6vpg8s4z-4>li:before{content:"-  "}ul.lst-kix_ltt0rgoz0br6-0{list-style-type:none}ul.lst-kix_ltt0rgoz0br6-5{list-style-type:none}ul.lst-kix_ltt0rgoz0br6-6{list-style-type:none}ul.lst-kix_ltt0rgoz0br6-3{list-style-type:none}ul.lst-kix_ltt0rgoz0br6-4{list-style-type:none}.lst-kix_jxdv6vpg8s4z-0>li:before{content:"-  "}.lst-kix_jxdv6vpg8s4z-1>li:before{content:"-  "}ul.lst-kix_ksrdahph672e-6{list-style-type:none}ul.lst-kix_ksrdahph672e-7{list-style-type:none}ul.lst-kix_ksrdahph672e-4{list-style-type:none}ul.lst-kix_ksrdahph672e-5{list-style-type:none}ul.lst-kix_ksrdahph672e-8{list-style-type:none}.lst-kix_jxdv6vpg8s4z-7>li:before{content:"-  "}.lst-kix_jxdv6vpg8s4z-6>li:before{content:"-  "}.lst-kix_jxdv6vpg8s4z-5>li:before{content:"-  "}.lst-kix_jxdv6vpg8s4z-8>li:before{content:"-  "}ul.lst-kix_ksrdahph672e-2{list-style-type:none}ul.lst-kix_ksrdahph672e-3{list-style-type:none}ul.lst-kix_ksrdahph672e-0{list-style-type:none}ul.lst-kix_ksrdahph672e-1{list-style-type:none}.lst-kix_jjby49jfkxyx-6>li:before{content:"-  "}.lst-kix_jjby49jfkxyx-8>li:before{content:"-  "}.lst-kix_jjby49jfkxyx-3>li:before{content:"-  "}.lst-kix_jjby49jfkxyx-7>li:before{content:"-  "}.lst-kix_jjby49jfkxyx-4>li:before{content:"-  "}.lst-kix_jjby49jfkxyx-5>li:before{content:"-  "}ul.lst-kix_list_3-7{list-style-type:none}ul.lst-kix_list_3-8{list-style-type:none}.lst-kix_jjby49jfkxyx-0>li:before{content:"-  "}ul.lst-kix_list_3-1{list-style-type:none}ul.lst-kix_list_3-2{list-style-type:none}ul.lst-kix_list_3-0{list-style-type:none}.lst-kix_jjby49jfkxyx-2>li:before{content:"-  "}ul.lst-kix_list_3-5{list-style-type:none}ul.lst-kix_list_3-6{list-style-type:none}ul.lst-kix_list_3-3{list-style-type:none}ul.lst-kix_list_3-4{list-style-type:none}.lst-kix_jjby49jfkxyx-1>li:before{content:"-  "}.lst-kix_ltt0rgoz0br6-2>li:before{content:"-  "}.lst-kix_ltt0rgoz0br6-1>li:before{content:"-  "}.lst-kix_ltt0rgoz0br6-3>li:before{content:"-  "}ul.lst-kix_hix68oawloq2-0{list-style-type:none}.lst-kix_ltt0rgoz0br6-6>li:before{content:"-  "}.lst-kix_ltt0rgoz0br6-7>li:before{content:"-  "}.lst-kix_ltt0rgoz0br6-0>li:before{content:"-  "}.lst-kix_ltt0rgoz0br6-8>li:before{content:"-  "}.lst-kix_bptz5kijd0at-5>li:before{content:"-  "}ul.lst-kix_hix68oawloq2-4{list-style-type:none}ul.lst-kix_hix68oawloq2-3{list-style-type:none}.lst-kix_bptz5kijd0at-3>li:before{content:"-  "}.lst-kix_bptz5kijd0at-4>li:before{content:"-  "}ul.lst-kix_hix68oawloq2-2{list-style-type:none}.lst-kix_ltt0rgoz0br6-5>li:before{content:"-  "}ul.lst-kix_hix68oawloq2-1{list-style-type:none}ul.lst-kix_hix68oawloq2-8{list-style-type:none}.lst-kix_ltt0rgoz0br6-4>li:before{content:"-  "}ul.lst-kix_hix68oawloq2-7{list-style-type:none}.lst-kix_bptz5kijd0at-2>li:before{content:"-  "}ul.lst-kix_hix68oawloq2-6{list-style-type:none}ul.lst-kix_hix68oawloq2-5{list-style-type:none}.lst-kix_gk0zq8hwve5q-8>li:before{content:"-  "}.lst-kix_gk0zq8hwve5q-7>li:before{content:"-  "}.lst-kix_bptz5kijd0at-6>li:before{content:"-  "}.lst-kix_hix68oawloq2-0>li:before{content:"-  "}.lst-kix_bptz5kijd0at-7>li:before{content:"-  "}.lst-kix_bptz5kijd0at-8>li:before{content:"-  "}.lst-kix_gk0zq8hwve5q-0>li:before{content:"-  "}.lst-kix_hix68oawloq2-1>li:before{content:"-  "}.lst-kix_hix68oawloq2-2>li:before{content:"-  "}.lst-kix_hix68oawloq2-3>li:before{content:"-  "}.lst-kix_hix68oawloq2-4>li:before{content:"-  "}.lst-kix_qwoq0ceavo4-4>li:before{content:"-  "}ul.lst-kix_gk0zq8hwve5q-6{list-style-type:none}.lst-kix_hix68oawloq2-7>li:before{content:"-  "}.lst-kix_hix68oawloq2-8>li:before{content:"-  "}ul.lst-kix_gk0zq8hwve5q-7{list-style-type:none}ul.lst-kix_gk0zq8hwve5q-8{list-style-type:none}.lst-kix_ksrdahph672e-0>li:before{content:"-  "}ul.lst-kix_gk0zq8hwve5q-2{list-style-type:none}.lst-kix_hix68oawloq2-5>li:before{content:"-  "}.lst-kix_hix68oawloq2-6>li:before{content:"-  "}ul.lst-kix_gk0zq8hwve5q-3{list-style-type:none}.lst-kix_qwoq0ceavo4-1>li:before{content:"-  "}.lst-kix_qwoq0ceavo4-5>li:before{content:"-  "}ul.lst-kix_gk0zq8hwve5q-4{list-style-type:none}ul.lst-kix_gk0zq8hwve5q-5{list-style-type:none}.lst-kix_qwoq0ceavo4-0>li:before{content:"-  "}.lst-kix_qwoq0ceavo4-8>li:before{content:"-  "}.lst-kix_qwoq0ceavo4-6>li:before{content:"-  "}.lst-kix_qwoq0ceavo4-7>li:before{content:"-  "}.lst-kix_gk0zq8hwve5q-1>li:before{content:"-  "}ul.lst-kix_jjby49jfkxyx-7{list-style-type:none}.lst-kix_gk0zq8hwve5q-2>li:before{content:"-  "}ul.lst-kix_jjby49jfkxyx-8{list-style-type:none}ul.lst-kix_jjby49jfkxyx-5{list-style-type:none}ul.lst-kix_jjby49jfkxyx-6{list-style-type:none}.lst-kix_gk0zq8hwve5q-4>li:before{content:"-  "}.lst-kix_gk0zq8hwve5q-3>li:before{content:"-  "}.lst-kix_gk0zq8hwve5q-6>li:before{content:"-  "}ul.lst-kix_jjby49jfkxyx-0{list-style-type:none}ul.lst-kix_gk0zq8hwve5q-0{list-style-type:none}ul.lst-kix_gk0zq8hwve5q-1{list-style-type:none}.lst-kix_qwoq0ceavo4-2>li:before{content:"-  "}ul.lst-kix_jjby49jfkxyx-3{list-style-type:none}ul.lst-kix_jjby49jfkxyx-4{list-style-type:none}.lst-kix_qwoq0ceavo4-3>li:before{content:"-  "}ul.lst-kix_jjby49jfkxyx-1{list-style-type:none}.lst-kix_gk0zq8hwve5q-5>li:before{content:"-  "}ul.lst-kix_jjby49jfkxyx-2{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c27{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#000000;border-left-style:solid;border-bottom-width:0pt;width:454.2pt;border-top-color:#000000;border-bottom-style:solid}.c37{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#33cc00;border-top-width:1pt;border-right-width:1pt;border-left-color:#33cc00;vertical-align:top;border-right-color:#33cc00;border-left-width:1pt;border-top-style:solid;background-color:#000000;border-left-style:solid;border-bottom-width:1pt;width:454.2pt;border-top-color:#33cc00;border-bottom-style:solid}.c59{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#33ff33;border-top-width:1pt;border-right-width:1pt;border-left-color:#33ff33;vertical-align:top;border-right-color:#33ff33;border-left-width:1pt;border-top-style:solid;background-color:#000000;border-left-style:solid;border-bottom-width:1pt;width:454.2pt;border-top-color:#33ff33;border-bottom-style:solid}.c56{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#351c75;border-top-width:1pt;border-right-width:1pt;border-left-color:#351c75;vertical-align:top;border-right-color:#351c75;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:95.4pt;border-top-color:#351c75;border-bottom-style:solid}.c69{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:95.4pt;border-top-color:#351c75;border-bottom-style:solid}.c74{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:middle;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:101.4pt;border-top-color:#000000;border-bottom-style:solid}.c95{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#351c75;border-top-width:1pt;border-right-width:1pt;border-left-color:#351c75;vertical-align:top;border-right-color:#351c75;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:89.9pt;border-top-color:#351c75;border-bottom-style:solid}.c20{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:101.4pt;border-top-color:#000000;border-bottom-style:solid}.c21{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:89.9pt;border-top-color:#000000;border-bottom-style:solid}.c63{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:78.6pt;border-top-color:#000000;border-bottom-style:solid}.c14{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:95.4pt;border-top-color:#000000;border-bottom-style:solid}.c81{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#351c75;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:89.9pt;border-top-color:#000000;border-bottom-style:solid}.c34{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:153.6pt;border-top-color:#000000;border-bottom-style:solid}.c26{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:100.7pt;border-top-color:#000000;border-bottom-style:solid}.c66{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:89.9pt;border-top-color:#351c75;border-bottom-style:solid}.c41{border-right-style:solid;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#000000;border-left-style:solid;border-bottom-width:0pt;width:454.2pt;border-top-color:#000000;border-bottom-style:solid}.c92{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#351c75;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:95.4pt;border-top-color:#000000;border-bottom-style:solid}.c64{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:153.5pt;border-top-color:#000000;border-bottom-style:solid}.c33{border-right-style:solid;padding:0pt 5.4pt 0pt 5.4pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:86.4pt;border-top-color:#000000;border-bottom-style:solid}.c1{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c40{color:#ff0000;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Times New Roman";font-style:normal}.c12{color:#000000;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c24{color:#ff6600;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c3{color:#00ff00;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c46{color:#ff99cc;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c45{color:#ffffff;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c49{color:#000000;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c35{color:#ff99cc;text-decoration:none;vertical-align:baseline;font-size:10pt;font-style:normal}.c78{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:right;margin-right:18pt}.c36{color:#000000;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman"}.c23{color:#000000;text-decoration:none;vertical-align:baseline;font-family:"Times New Roman";font-style:normal}.c25{color:#ff0000;text-decoration:none;vertical-align:baseline;font-size:10pt;font-style:normal}.c38{color:#000000;text-decoration:none;vertical-align:baseline;font-size:10pt;font-style:normal}.c60{color:#ff0000;text-decoration:none;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c51{color:#000000;text-decoration:none;vertical-align:baseline;font-size:12pt}.c16{border-spacing:0;border-collapse:collapse;margin-right:auto}.c68{text-decoration:none;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c82{color:#00ff00;text-decoration:none;font-family:"Times New Roman";font-style:normal}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c8{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:center}.c39{margin-left:auto;border-spacing:0;border-collapse:collapse;margin-right:auto}.c86{text-decoration:none;font-family:"Times New Roman";font-style:normal}.c10{font-size:10pt;font-family:"Courier New";color:#00ff00}.c91{background-color:#ffffff;max-width:454.2pt;padding:70.6pt 70.6pt 70.6pt 70.6pt}.c15{vertical-align:super;font-size:11pt;color:#ff0000}.c43{padding-top:12pt;padding-bottom:3pt;line-height:1.0}.c85{color:#000000;font-family:"Times New Roman";font-style:normal}.c83{padding-top:0pt;padding-bottom:0pt;line-height:1.0}.c54{font-size:11pt;font-family:"Arial"}.c53{padding:0;margin:0}.c31{margin-left:36pt;padding-left:0pt}.c50{margin-left:70.8pt;text-indent:35.4pt}.c2{color:#1155cc;text-decoration:underline}.c17{color:inherit;text-decoration:inherit}.c89{text-decoration:none;font-style:normal}.c7{color:#339966;font-weight:700}.c28{font-size:10pt;color:#ff0000}.c80{font-size:14pt;color:#ff0000}.c42{font-size:10pt;color:#ff99cc}.c62{font-size:8pt}.c32{font-style:italic}.c87{color:#f3f3f3}.c65{color:#cc99ff}.c4{margin-left:18pt}.c6{height:0pt}.c70{margin-left:36pt}.c30{font-family:"Verdana"}.c58{vertical-align:baseline}.c47{color:#0000ff}.c55{color:#ff6600}.c76{color:#4c1130}.c9{text-indent:36pt}.c13{height:12pt}.c61{height:14pt}.c67{text-align:justify}.c52{color:#00ffff}.c94{color:#000000}.c44{font-size:10pt}.c0{font-weight:400}.c29{text-decoration:underline}.c90{color:#ff0000}.c18{font-size:20pt}.c72{color:#993300}.c88{text-align:left}.c96{margin-right:18pt}.c93{color:#38761d}.c48{color:#339966}.c22{text-align:center}.c71{vertical-align:super}.c79{font-size:16pt}.c77{color:#c0c0c0}.c73{color:#666666}.c11{font-weight:700}.c57{color:#ffffff}.c84{color:#008000}.c19{font-family:"Courier New"}.c75{color:#ff00ff}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Times New Roman";line-height:1.0;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.0;font-style:italic;text-align:left}li{color:#000000;font-size:12pt;font-family:"Times New Roman"}p{margin:0;color:#000000;font-size:12pt;font-family:"Times New Roman"}h1{padding-top:12pt;color:#000000;font-weight:700;font-size:16pt;padding-bottom:3pt;font-family:"Arial";line-height:1.0;text-align:left}h2{padding-top:12pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:3pt;font-family:"Arial";line-height:1.0;font-style:italic;text-align:left}h3{padding-top:12pt;color:#000000;font-weight:700;font-size:13pt;padding-bottom:3pt;font-family:"Arial";line-height:1.0;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:3pt;font-family:"Times New Roman";line-height:1.0;text-align:left}h5{padding-top:12pt;color:#000000;font-weight:700;font-size:13pt;padding-bottom:3pt;font-family:"Times New Roman";line-height:1.0;font-style:italic;text-align:left}h6{padding-top:12pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:3pt;font-family:"Times New Roman";line-height:1.0;text-align:left}</style></head><body class="c91"><p class="c22 title" id="h.n3fi8n9xf1iz"><span class="c0">Assembly for the SNES</span></p><p class="c22 subtitle" id="h.ru26oju4mzbg"><span class="c0">An ASM tutorial</span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13 c22"><span class="c0"></span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">Author</span><span class="c0">: Ersanio<br></span><span class="c11">Date of publishing</span><span class="c0">: 3rd of February, 2016</span></p><p class=""><span class="c11">Latest update:</span><span class="c0">&nbsp;19th of August, 2016</span></p><p class=""><span class="c11">Website</span><span class="c0">: http://www.smwcentral.net/ || </span><span class="c11">Personal Website:</span><span class="c0">&nbsp;http://ersan.io/</span><span class="c0"><br></span><span class="c11">Version</span><span class="c0">: 2.3</span></p><h4 class="c22" id="h.721q6zcs7kuk"><span class="c0 c18">Preface</span></h4><p class=""><span class="c0">This is an ASM tutorial written by me, Ersanio. I wrote this tutorial in order to teach other people 65c816 assembly. In the past, kept bugging me to explain to them how assembly works, and because I am too lazy to individually explain it to everyone, I just felt like doing it the easy way. I&rsquo;m not good at teaching anyway, so I thought writing a complete tutorial was sufficient. In this tutorial, I will try to cover everything as detailed as possible. If you don&rsquo;t like wall of text mixed with examples, this is not something for you. Also, personally I think I&rsquo;m better at making documents rather than explaining things individually to people, because for documents I actually have the time to think thoroughly about topics.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">This tutorial does NOT use Super Mario World&rsquo;s RAM addresses by default. This tutorial is for 65c816 ASM used by the SNES </span><span class="c0 c29">in general</span><span class="c0">. The tutorial is not game-specific. </span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Before you&rsquo;re going to wonder: No, there is no specific ASM coding tool. Your ultimate coding tool will be Notepad! (Or another ASCII text file editor). By default, my ASM files are encoded in ANSI which never gave me any problems regarding assembling files so far. To assemble an assembly file (usually with the extension .asm), you use high-end assemblers, like </span><span class="c11">xkas</span><span class="c0">&nbsp;(author: byuu). xkas is a good assembler, although SMWCentral is in the process of switching to </span><span class="c11">asar</span><span class="c0">&nbsp;(which is essentially the same as xkas, except it has more features and less bugs)</span><span class="c0">. Particularly, in this tutorial I am following the syntax of </span><span class="c11">xkas 0.06</span><span class="c0">. I&rsquo;d use later versions but SMWC had </span><span class="c11">xkas 0.06</span><span class="c0">&nbsp;as its standard for a long time. Also, if you find trasm.exe/tricks assembler, trash it immediately. That thing is horrible.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">I tried to make the previous version of this tutorial as beginners-friendly as possible. However, in the end people recommended that you have basic ASM knowledge before starting this tutorial. If you ever find a part</span><span class="c11">&nbsp;</span><span class="c0">you don&rsquo;t understand</span><span class="c0">, or you find a mistake in this tutorial, </span><span class="c11">don&rsquo;t hesitate to contact me</span><span class="c0">. I&rsquo;d like to </span><span class="c0">improve </span><span class="c0">this tutorial any day to make it beginners-friendly. If you don&rsquo;t understand something, contact me, and I&rsquo;ll try to improve the wrong parts of this tutorial.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Chapters marked as </span><span class="c15 c11">Important </span><span class="c0">teach fundamentals which are required in order to learn ASM, e.g. a new counting system.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">For the more technical people, please keep in mind I&rsquo;m using the mapping mode &ldquo;LoROM&rdquo;.</span></p><p class="c13 c67"><span class="c0"></span></p><p class="c67"><span class="c0">If you ever want to contact me for whatever reason, you can find me at:</span></p><p class=""><span class="c47 c0 c29"><a class="c17" href="https://www.google.com/url?q=http://www.smwcentral.net/&amp;sa=D&amp;ust=1471566887100000&amp;usg=AFQjCNFbC_9TEXfDbfdeXmf_A-YOyhcBGQ">http://www.smwcentral.net/</a></span><span class="c0">&nbsp;as user ID 3, Ersanio</span></p><p class=""><span class="c2 c0"><a class="c17" href="https://www.google.com/url?q=http://ersan.io/&amp;sa=D&amp;ust=1471566887101000&amp;usg=AFQjCNFnjnGRAfLJNut4Z7LnjI-lm5ahEQ">http://ersan.io/</a></span><span class="c0">&nbsp;my own website</span></p><p class=""><span class="c0">IRC: irc.caffie.net, channels #smwc and #serioushax, as Ersanio</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Many special thanks go to certain ASM people for directly (and indirectly) teaching me assembly:</span></p><p class=""><span class="c11">Bio, &nbsp;Killozapit, MiOr, schwa, Smallhacker, smkdan, Sukasa, Roy</span></p><p class="c13"><span class="c11"></span></p><p class=""><span class="c0">Many thanks go to certain people for providing feedback and suggestions:</span></p><p class=""><span class="c11">spigmike, Roy, smkdan, S.N.N, andy_k_250, Domiok, reghrhre, Chaoticfox, Tails_155, GreenHammerBro, VitorVilela</span></p><h4 class="c22" id="h.lwx2nbze8nkg"><span class="c0 c18">Changelog</span></h4><p class=""><span class="c11">Version 2.3</span></p><ul class="c53 lst-kix_gk0zq8hwve5q-0 start"><li class="c31"><span class="c0">Above page updated to include new people in the feedback/suggestions list.</span></li><li class="c31"><span class="c0">Chapter 10: Fixed BCC typo (was BCS).</span></li><li class="c31"><span class="c0">Chapter 10: Added additional information about BCC not checking for equality, unlike BCS</span></li><li class="c31"><span class="c0">Chapter 22: First part about BEQ, BNE updated to explain that CMP also plays with the carry flag.</span></li><li class="c31"><span class="c0">Chapter 21: Added point of advice about all pulling instructions affecting the negative and zero flag.</span></li><li class="c31"><span class="c0">Chapter 7: Direct Page explanation slightly improved to explain that there is some address mirroring going on.</span></li><li class="c31"><span class="c0">Chapter 11: Point of Advice about &ldquo;Program Bank not updating when it follows a JMP/JML&rdquo; updated to say &ldquo;Data Bank&rdquo; and &ldquo;JSL/JML&rdquo; instead. Yeah, I don&rsquo;t know what I was thinking either, Vitor.</span></li><li class="c31"><span class="c0">Chapter 13: Overflow flag further explored in possibilities, point of advice slightly less awkward now.</span></li><li class="c31"><span class="c0">Chapter 5: SRAM explanation was completely wrong, I fixed it.</span></li><li class="c31"><span class="c0">Chapter 4: The SNES memory map image is updated to reflect the fixed SRAM changes.</span></li></ul><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">Version 2.2</span></p><ul class="c53 lst-kix_ksrdahph672e-0 start"><li class="c31"><span class="c0">Vast improvement over the previous version but because it has been years I forgot what the changes are. The only notable changes are:</span></li><li class="c31"><span class="c0">Fancy code boxes</span></li><li class="c31"><span class="c0">Fancy points of advices</span></li><li class="c31"><span class="c0">Explanations have been made more clear</span></li><li class="c31"><span class="c0">Fixed very minor errors</span></li><li class="c31"><span class="c0">Thrown out the decimal mode because it isn&rsquo;t even emulated properly in most emulators, and it is used rarely anyway.</span></li></ul><p class="c13"><span class="c11"></span></p><hr style="page-break-before:always;display:none;"><p class="c13 c22"><span class="c0"></span></p><p class="c13 c88"><span class="c0"></span></p><h4 class="" id="h.m22rgkmn5aub"><span class="c0 c18">Table of contents</span></h4><p class="c4"><span class="c2 c0"><a class="c17" href="#h.721q6zcs7kuk">Preface</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.lwx2nbze8nkg">Changelog</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.m22rgkmn5aub">Table of contents</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.2hd6aal1v0ue">Chapter 1: Introduction to 65c816 Assembly</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.joroueq1xlcf">Chapter 2: Hexadecimal, a new counting system Important</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.13u8tiggql9">Chapter 3: Ones and Zeros (+ Summary) Important</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.7ta0jt2o0pn6">Chapter 4: Values and Addresses Important</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.ayz18ig02jjb">Chapter 5: ROM and (S)RAM Important</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.ti3bj41nhldk">Chapter 6: General registers Important</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.wq2no7e7mnoi">Chapter 7: Addressing modes &amp; other names &nbsp;Important</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.op6c9hbjmn8r">Chapter 8: Little Endian</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.zfpotxk7c096">Chapter 9: Loading and Storing</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.pmhjv25ylybj">Chapter 10: Branching, Labels and Comparing</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.99uk38ge9rel">Chapter 11: Jumping to (sub)routines</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.hkfm12qu7b4r">Chapter 12: Carry Flag</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.pdluakcmslk4">Chapter 13: Adding and Subtracting</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.shr1gz8ovxq5">Chapter 14: Bit Shifting</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.i3j0vsbhg7k7">Chapter 15: Bitwise Operations</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.rkoelvi8slkj">Chapter 16: Affecting Processor Flags manually</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.aazbl4mjcn64">Chapter 17: Moving chunks of data</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.jsiajsqzqisf">Chapter 18: Indexing with X and Y</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.aa9xafku5faw">Chapter 19: Transfer</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.x6wso9plphn">Chapter 20: Miscellaneous Opcodes</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.qr5bqe7y71lm">Chapter 21: Stack; Push and Pull &nbsp;Important</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.7o9mnt86asdy">Chapter 22: In-depth look at some opcodes</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.7wuxy5zauavi">Chapter 23: In-depth look into Processor Flags &nbsp;Important</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.do7k5a6dexr">Chapter 24: In-depth look into Addressing modes</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.31evv0aoa2ig">Chapter 25: Indirect pointers to routines</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.ojb6kziwvwly">Chapter 26: Machine Cycles</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.ujr33qj61ygq">Chapter 27: Useless opcodes</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.k5grc6lsip6i">Chapter 28: Tips and tricks</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.1lohk3ajdceg">Chapter 29: Programming cautions Important</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.g4fcc49qji5d">Chapter 30: Useful links</a></span></p><p class="c4"><span class="c2 c0"><a class="c17" href="#h.94tivrmhcic3">Chapter 31: Final notes</a></span></p><hr style="page-break-before:always;display:none;"><h4 class="c43 c22" id="h.2hd6aal1v0ue"><span class="c0 c18">Chapter 1: Introduction to 65c816 Assembly</span></h4><p class="c83"><span class="c0">You might have heard </span><span class="c0">of </span><span class="c0">ASM, or 65c816, or assembly. So what is ASM? ASM stands for AsSeMbly. Breaking down the different parts of the acronym 65c816, the 816 </span><span class="c0">means</span><span class="c0">&nbsp;that the processor can be either 8-bit mode or 16-bit mode. The c stands for CMOS, 65 means that this processor is from the 65xx CPU family.</span><span class="c0">&nbsp;T</span><span class="c0">he processor is supposed to be pretty </span><span class="c0">revolutionary for its time.</span><span class="c0">&nbsp;In this tutorial I will explain mnemonics/instructions (I call them opcodes), and how to use them properly. This tutorial will not focus on things like SNES hardware registers.</span></p><p class="c83 c13"><span class="c0"></span></p><p class="c83"><span class="c0">With 65c816 ASM you can code stuff for SNES games (such as custom features for Super Mario World). ASM is a 2nd generation programming language (which is low-level compared to C# for example). It is readable machine code, which eventually gets translated into hexadecimal machine code. All the opcodes consist of 3 letters, along with various parameters.</span><span class="c0">&nbsp;But before </span><span class="c0">you</span><span class="c0">&nbsp;</span><span class="c0">start learning ASM, you&rsquo;ll have to learn various basics which are extremely important!</span></p><hr style="page-break-before:always;display:none;"><h4 class="c43" id="h.joroueq1xlcf"><span class="c0 c18">Chapter 2: Hexadecimal, a new counting system </span><span class="c15 c0">Important</span></h4><p class=""><span class="c0">To program in 65c816 ASM, you will need </span><span class="c0">to grasp the basics of</span><span class="c0">&nbsp;hexadecimal</span><span class="c0">.</span><span class="c0">&nbsp;Hexadecimal, also known as</span><span class="c0">&nbsp;</span><span class="c11">hex</span><span class="c0">,</span><span class="c0">&nbsp;is </span><span class="c0">a counting system </span><span class="c0">like decimal (everyday counting syste</span><span class="c0">m people use</span><span class="c0">), but there are additional 6 digits per place value. Take a look at this table for an example:</span></p><p class="c13 c22"><span class="c0"></span></p><a id="t.15620388044175fa291b4747779aaddbd883e493"></a><a id="t.0"></a><table class="c39"><tbody><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c11">Decimal</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c11">Hexadecimal</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0x0</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">1</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0x1</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">2</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0x2</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">3</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0x3</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">4 </span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0x4</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">5</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0x5</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">6</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0x6</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">7</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0x7</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">8</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0x8</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">9</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0x9</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">10</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0xA</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">11</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0xB</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">12</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0xC</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">13</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0xD</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">14</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0xE</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">15</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0xF</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">16</span></p></td><td class="c26" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">0x10</span></p></td></tr></tbody></table><p class="c22"><span class="c0">And the numbers will continue like 11, 12, 13 &hellip; 1A, 1B, 1C and so on&hellip; </span></p><p class="c13 c22"><span class="c0"></span></p><p class=""><span class="c0">There are various ways to write hex numbers so readers cannot confuse them with actual decimal numbers. You can </span><span class="c32 c0">prefix</span><span class="c0">&nbsp;hexadecimal numbers with 0x, or $, or </span><span class="c32 c0">suffix</span><span class="c0">&nbsp;them with H. Example: 0x00, $00, 00H. In this tutorial, $ is always used but in most other programming languages 0x is used instead.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">In assembly, depending on the game&rsquo;s programming, </span><span class="c0">values $80 and higher </span><span class="c0">are considered as</span><span class="c0">&nbsp;</span><span class="c11">negative</span><span class="c0">&nbsp;numbers, starting from -128, and counting down as the hex number increases. So&hellip;</span></p><p class="c13 c22"><span class="c0"></span></p><a id="t.05404c79405650e1848a44b1cd05613f070af32d"></a><a id="t.1"></a><table class="c39"><tbody><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c1">Decimal</span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c8"><span class="c11">Hexadecimal</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c0">126</span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c8"><span class="c0">$7E</span></p></td></tr><tr class="c6"><td class="c81" colspan="1" rowspan="1"><p class="c8"><span class="c0">127</span></p></td><td class="c92" colspan="1" rowspan="1"><p class="c8"><span class="c0">$7F</span></p></td></tr><tr class="c6"><td class="c95" colspan="1" rowspan="1"><p class="c8"><span class="c0">-</span><span class="c12 c0">128</span></p></td><td class="c56" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$80</span></p></td></tr><tr class="c6"><td class="c66" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">-127</span></p></td><td class="c69" colspan="1" rowspan="1"><p class="c8"><span class="c0">$</span><span class="c12 c0">81</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c0">[...]</span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c8"><span class="c0">[...]</span></p></td></tr><tr class="c6"><td class="c21" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">-1</span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c8"><span class="c0">$</span><span class="c12 c0">FF</span></p></td></tr></tbody></table><p class="c13 c22"><span class="c0"></span></p><p class="c88"><span class="c0">The presence of negative numbers depends on the game&rsquo;s programming though. For example, a player can have positive and negative speed (going forward and backwards), but a player can not have negative extra lives or points (because it usually doesn&rsquo;t make sense). Of course, there&rsquo;s no number -0, hence you can reach -128 with negative numbers, because 0xFF is treated as -1, not &ldquo;-0&rdquo;</span></p><h4 class="c22" id="h.13u8tiggql9"><span class="c0 c18">C</span><span class="c18 c11">hapter 3: Ones and Zeros (+ Summary) </span><span class="c15 c11">Important</span></h4><p class=""><span class="c0">Another important counting system is &ldquo;binary&rdquo;. B</span><span class="c0">inary has only 2 possible values for each place value: 0 and 1.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">In our current ASM context, a hexadecimal number with 2 digits is called a &ldquo;byte&rdquo;. Values between $00-$FF is considered a &ldquo;byte&rdquo;. A byte is made of eight &ldquo;bits&rdquo;. These eight bits can only have 0 or 1 as its value. For example, a byte can consist of the following bits:</span><span class="c0">&nbsp;1001 0110 or 1001 0101 or whichever from the 256 combinations of 0 and 1. </span><span class="c0">The first bit (from the left) is called &ldquo;bit 7&rdquo; and the final bit is called &ldquo;bit 0&rdquo;, NOT bits 1-8.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Learning binary can take some time. The easiest way to start off with learning binary is memorizing the small table below:</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">7654 3210</span></p><p class=""><span class="c47 c0">0000</span><span class="c0">&nbsp;</span><span class="c0 c48">0001</span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= </span><span class="c11">$</span><span class="c47 c11">0</span><span class="c7">1</span></p><p class=""><span class="c47 c0">0000</span><span class="c0">&nbsp;</span><span class="c0 c48">0010</span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= </span><span class="c11">$</span><span class="c47 c11">0</span><span class="c7">2</span></p><p class=""><span class="c47 c0">0000</span><span class="c0">&nbsp;</span><span class="c0 c48">0100</span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= </span><span class="c11">$</span><span class="c11 c47">0</span><span class="c7">4</span></p><p class=""><span class="c47 c0">0000</span><span class="c0">&nbsp;</span><span class="c0 c48">1000</span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= </span><span class="c11">$</span><span class="c47 c11">0</span><span class="c7">8</span></p><p class=""><span class="c47 c0">0001</span><span class="c0">&nbsp;</span><span class="c0 c48">0000</span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= </span><span class="c11">$</span><span class="c47 c11">1</span><span class="c7">0</span></p><p class=""><span class="c47 c0">0010</span><span class="c0">&nbsp;</span><span class="c0 c48">0000</span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= </span><span class="c11">$</span><span class="c47 c11">2</span><span class="c7">0</span></p><p class=""><span class="c47 c0">0100</span><span class="c0">&nbsp;</span><span class="c0 c48">0000</span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= </span><span class="c11">$</span><span class="c47 c11">4</span><span class="c7">0</span></p><p class=""><span class="c47 c0">1000</span><span class="c0">&nbsp;</span><span class="c0 c48">0000</span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= </span><span class="c11">$</span><span class="c47 c11">8</span><span class="c7">0</span></p><p class="c13"><span class="c7"></span></p><p class=""><span class="c0">Note that all of these bolded values are in </span><span class="c11">hexadecimal</span><span class="c0">! Note that I also put a space after 4 digits </span><span class="c11">for easier readability</span><span class="c0">. 4 </span><span class="c0">bits a</span><span class="c0">re called</span><span class="c11">&nbsp;&lsquo;nibbles&rsquo;</span><span class="c0">&nbsp;and they are easier to read, because one nibble corresponds to one digit in hexadecimal.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">So as you can see, the blue bits are part of the blue digit of the hexadecimal numbers. The green bits are part of the green digit of the hexadecimal numbers. Also, there are 16 combinations possible for 4 bits, so the numbers a hexadecimal digit can have is 0-F. This makes binary </span><span class="c0">&larr;&rarr; hex conversion very easy, all thanks to nibbles.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">The SNES is capable of working with both 8- and 16-bit numbers.</span><span class="c0">&nbsp;</span><span class="c0">&ldquo; </span><span class="c0">16-bit mode</span><span class="c0">&rdquo; </span><span class="c0">&nbsp;of course makes hexadecimal numbers use 16 bits: </span><span class="c0 c72">xxxx</span><span class="c0 c84">xxxx</span><span class="c0">&nbsp;</span><span class="c0 c75">xxxx</span><span class="c65 c0">xxxx </span><span class="c0">in binary, which is $</span><span class="c0 c72">x</span><span class="c0 c84">x</span><span class="c0 c75">x</span><span class="c0 c65">x </span><span class="c0">in hexadecimal. It has the same concept as the above paragraph. Example: 1111 0000 1111 0000 would be $F0F0. In this case, the first </span><span class="c0">x here is called &ldquo;bit 15&rdquo; and the final x is called &ldquo;bit 0&rdquo;.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Binary is useful if you&rsquo;re giving a hex number multiple purposes. That way, you can save some bytes in the ROM or RAM.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">For example, you can make the game programming say that bit 7 indicates that the level has rain or not, that bit 6 indicates that a level layout is horizontal or vertical, that bit 5 indicates that the level setting is during day or night, etc. You probably noticed that I&rsquo;m using &ldquo;or&rdquo; a lot. Because bits can have two values only, the effects can be treated as &ldquo;</span><span class="c11">either</span><span class="c0">&nbsp;this </span><span class="c11">or</span><span class="c0">&nbsp;that&rdquo;. The level has either rain or no rain, there&rsquo;s no inbetween. Such values are called </span><span class="c11">flags</span><span class="c0">.</span></p><p class="c13"><span class="c0"></span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Of course, bits aren&rsquo;t solely restricted to be used in flags. In the end, combinations of them make up a number.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Here is</span><span class="c0">&nbsp;a general overview of counting in hex and binary:</span></p><p class="c13 c22"><span class="c0"></span></p><a id="t.b48476a2f1382837c29f3ee9f140299554dac933"></a><a id="t.2"></a><table class="c39"><tbody><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c1">Decimal</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c1">Hexadecimal</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c11">Binary</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">00</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$00</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 0000</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">01</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$01</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 0001</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">02</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$02</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 0010</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">03</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$03</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 0011</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">04</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$04</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 0100</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">05</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$05</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 0101</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">06</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$06</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 0110</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">07</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$07</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 0111</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">08</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$08</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 1000</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">09</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$09</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 1001</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">10</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$0A</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 1010</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">11</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$0B</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 1011</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">12</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$0C</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 1100</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">13</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$0D</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 1101</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">14</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$0E</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 1110</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">15</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$0F</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0000 1111</span></p></td></tr><tr class="c6"><td class="c33" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">16</span></p></td><td class="c74" colspan="1" rowspan="1"><p class="c8"><span class="c12 c0">$10</span></p></td><td class="c63" colspan="1" rowspan="1"><p class="c8"><span class="c0">%</span><span class="c12 c0">0001 0000</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">In assemblers, a % prefix indicates a binary value.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Sometimes you will encounter binary digits such as 11 or 110 0000. You&rsquo;ll notice that they aren&rsquo;t 8 or 16 digits.</span><span class="c0">&nbsp;This makes the binary number harder to read. To make them readable, y</span><span class="c0">ou will need to add leading 0s to the digits until you have either 8 bits or 16 bits in tot</span><span class="c0">al, whichever you desire</span><span class="c0">. </span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">In 8-bit:</span></p><p class=""><span class="c0 c48">11</span><span class="c0">&nbsp;becomes 000000</span><span class="c0 c48">11</span></p><p class=""><span class="c0 c48">1100000</span><span class="c0">&nbsp;becomes 0</span><span class="c0 c48">1100000</span></p><p class="c13"><span class="c0 c48"></span></p><p class=""><span class="c0">In 16-bit:</span></p><p class=""><span class="c0 c48">11</span><span class="c0">&nbsp;becomes 00000000 000000</span><span class="c0 c48">11</span></p><p class=""><span class="c0 c48">1100000</span><span class="c0">&nbsp;becomes 00000000 0</span><span class="c0 c48">1100000</span></p><p class="c13"><span class="c0 c48"></span></p><p class=""><span class="c0">Y</span><span class="c0">ou can also convert decimal, hexadecimal and binary easily by using </span><span class="c0">W</span><span class="c0">indows calculator&rsquo;s</span><span class="c0">&nbsp;programming mode</span><span class="c0">. You can also </span><span class="c0">find convertors online.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">In assembly, you generally don&rsquo;t have to convert between decimal and hexadecimal unless you&rsquo;re working with decimal numbers. For example, if you want a player to receive an extra life after receiving 100 coins, you&rsquo;ll have to check for the number 100 in the game&rsquo;s programming. In assembly, 100 is the hex number $64. If you don&rsquo;t know this by heart, you&rsquo;ll just have to use a converter to convert 100 into its hex equivalent.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">If you&rsquo;re working with things like speed however, you don&rsquo;t really have to know how fast $53 is, as long as the speed is &lsquo;good enough&rsquo; for you, you don&rsquo;t have to worry about the decimal meaning of $53.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Regardless, most assemblers also support decimal notations so you don&rsquo;t have to convert numbers to hexadecimal.</span></p><hr style="page-break-before:always;display:none;"><p class="c13"><span class="c0"></span></p><h4 class="c22" id="h.7ta0jt2o0pn6"><span class="c0 c18">Chapter 4: Values and Addresses </span><span class="c15 c0">Important</span></h4><p class=""><span class="c0">Before you start coding in ASM, you also have to know </span><span class="c11">what</span><span class="c0">&nbsp;you are doing. Imagine the following: You&rsquo;re loading a </span><span class="c0">value</span><span class="c0">&nbsp;and decide to store it at an address. You won&rsquo;t really know what effect it will have, or even worse, not know if the store takes effect at all! This is why you need to know how addresses work.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">For the beginners: The SNES Memory is a field of numb</span><span class="c0">ers, either ROM or RAM. ROM is a range of static numbers which can be read as code or numerical data. RAM is capable of storing dynamic numerical data (numbers) which can be read and modified by code. </span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Each number has an &ldquo;Address&rdquo; assigned to it. The SNES memory</span><span class="c0">&nbsp;is mapped from address $000000 to $FFFFFF, although only $000000-$7FFFFF is </span><span class="c0">used in most cases</span><span class="c0">. The format of an </span><span class="c0">address </span><span class="c0">is: $</span><span class="c0">BBHHDD</span><span class="c0">.</span></p><p class="c13"><span class="c11"></span></p><p class=""><span class="c11">BB </span><span class="c0">is the </span><span class="c11">bank</span><span class="c0">&nbsp;byte of the offset</span></p><p class=""><span class="c11">HH </span><span class="c0">is the </span><span class="c11">high</span><span class="c0">&nbsp;byte of the offset</span></p><p class=""><span class="c11">DD </span><span class="c0">is the </span><span class="c11">low</span><span class="c0">&nbsp;byte of the offset.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">The addresses can be written in 3 ways: $BBHHDD, $HHDD and $DD, such as $7E0003, $0003 and $03.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">When </span><span class="c0">DD </span><span class="c0">is used alone, it is called a &ldquo;</span><span class="c0">d</span><span class="c0">irect page address&rdquo;.</span></p><p class=""><span class="c0">When </span><span class="c0">HHDD are</span><span class="c0">&nbsp;together, it is called an </span><span class="c0">&ldquo;</span><span class="c0">absolute address</span><span class="c0">&rdquo;</span></p><p class=""><span class="c0">When BBHHDD are together, it is called a &ldquo;</span><span class="c0">long address&rdquo;.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">The memory </span><span class="c0">consists of</span><span class="c0">&nbsp;multiple parts though. For example, when the high byte is $80 or higher, and the bank byte is $6F or lower, you will be accessing ROM: $</span><span class="c0">6F8000, $668823, etc</span><span class="c0">. Or if the bank is $7E, you will be accessing the RAM: $7E4932. Here&rsquo;s a simple drawing to get a general overview of the basic SNES memory (also known as a memory map</span><span class="c0">)</span><span class="c0">:</span></p><p class=""><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 581.00px; height: 360.00px;"><img alt="" src="images/image01.png" style="width: 581.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class=""><span class="c0 c73">The &ldquo;LoROM&rdquo; Memory Map</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">As you can see, code executing in banks $40-$6F will not be able to access the mirror RAM and the hardware registers, because they don&rsquo;t exist in those banks. Accessing address $251337 is exactly the same as accessing address $7E1337. There&rsquo;s a chapter dedicated to the ROM and RAM later in the tutorial. About &ldquo;*area you never should have to access*&rdquo; parts&hellip; I don&rsquo;t know what they are used for, but I never ever had to access these areas so far</span><span class="c0">, but I don&rsquo;t think I&rsquo;ve been missing out on anything crucial or revolutionary. </span><span class="c0">About the ROM areas: You can only load things from there, not store. It&rsquo;s living up to its name: &ldquo;Read-only memory&rdquo;. I mean, you could try storing things there, but nothing will change</span><span class="c0">&nbsp;at all.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Values also have names. Values are numbers you use to fill in a parameter, or for math, or other things.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">A 2-digit value is a </span><span class="c11">byte ($XX). </span><span class="c0">Abbreviation is &ldquo;db&rdquo; for tables</span></p><p class=""><span class="c0">A 4-digit value is a </span><span class="c11">word ($XXXX). </span><span class="c0">Abbreviation is &ldquo;dw&rdquo; for tables</span></p><p class=""><span class="c0">A 6-digit value is a </span><span class="c11">long ($XXXXXX). </span><span class="c0">Abbreviation is &ldquo;dl&rdquo; for tables.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Tables are </span><span class="c0">later </span><span class="c0">explained in the indexing chapter.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">If a value is 1, 3, or 5 digits, add a leading zero to it (for example: $1 </span><span class="c30 c0">&rarr;</span><span class="c0">&nbsp;</span><span class="c0">$01, </span></p><p class=""><span class="c0">$6969F </span><span class="c30 c0">&rarr; </span><span class="c0">$06969F, and so on). You should do this for easier readability. Keep in mind that we&rsquo;re still working with hexadecimal here!</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Also, each address can hold a single byte as we established earlier. Writing to a specific address in 16-bit mode will involve address+1 too, because a 16-bit number takes up two bytes.</span></p><p class="c13 c22"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c13 c22"><span class="c0"></span></p><h4 class="c43 c22" id="h.ayz18ig02jjb"><span class="c0 c18">Chapter 5: ROM and (S)RAM </span><span class="c15 c0">Important</span></h4><p class=""><span class="c0">This is probably the most important part of this tutorial. RAM is basically a bunch of dynamic variables used by the ROM. ROM and RAM are located in the SNES memory (see chapter 4).</span></p><p class=""><span class="c0">&nbsp;</span></p><p class=""><span class="c0">Once again, ROM means &lsquo;Read-Only Memory&rsquo;. It cannot be modified by using ASM. You can say it is the game itself, which contains all the ASM data, codes, tables, graphics, music, and so on, which emulators can load and run. Or: It&rsquo;s the .smc/.sfc/.fig/etc. file.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">RAM is &lsquo;Random Access Memory&rsquo;. Another word for RAM is simply &ldquo;Memory&rdquo;, but RAM is the preferred term. It&rsquo;s a collection of bytes which contains dynamic variables of various functions. The SNES RAM is 128kB big, and it is located at offset $7E0000-$7FFFFF.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">A &ldquo;RAM address&rdquo; is a specific place in the RAM. There&rsquo;s nothing else to it. For example, if we say that RAM address $7E0000 contains the number $55, then RAM $7E0000 contains the number $55. It&rsquo;s that simple.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">The RAM can hold numbers important to the game but which can change a lot. For example, extra lives, or the player&rsquo;s score. For example, if you write $04 to the player&rsquo;s extra lives, then the player will have exactly 4 extra lives. It doesn&rsquo;t get added up to the current extra lives. As for the ROM, it holds the game&rsquo;s logic and art like the game&rsquo;s programming and graphics. SNES RAM is completely dynamic. There is no such rule as &ldquo;Address $7E0120 is used for lives in every SNES game ever.&rdquo; You define the purpose of RAM yourself by writing ASM code.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">A small portion of the RAM is also used for the &ldquo;stack&rdquo;. This portion of RAM is often located at $7E0000-$7E1FFF. The stack is explained later in this tutorial.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">RAM addresses $7E0000-$7E1FFF are also </span><span class="c11">mirrored</span><span class="c0">&nbsp;at the following locations:</span></p><p class=""><span class="c0">$000000-$001FFF</span></p><p class=""><span class="c0">$010000-$011FFF</span></p><p class=""><span class="c0">$020000-$021FFF</span></p><p class=""><span class="c0">&hellip;</span></p><p class=""><span class="c0">$3F0000-$3F1FFF</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">So for example, writing to $210000 would equal writing to $7E0000 automatically. You can find this information in the drawing in the previous chapter.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">When the SNES resets, the RAM also resets (on real hardware, it resets to random values. In emulators it&rsquo;s often $55). But there&rsquo;s also a non-resetting RAM which allows the game to save data. This RAM is called the </span><span class="c11">SRAM</span><span class="c0">. It is also 128kB big, and it is located in blocks of 32kB at $700000-$707FFF, $710000-$717FFF, $720000-$727FFF and $730000-$737FFF, although the final size of SRAM depends on the ROM specifications itself (thanks to something called the &ldquo;Internal ROM header&rdquo;). The SRAM isn&rsquo;t mirrored in other banks. SRAM behaves exactly like the RAM; you can store anything and load anything from it, but the values do not get cleared when the SNES resets! The SRAM is backed up with an actual battery on a real SNES cartridge. When the battery dies or is removed, SRAM will cease to function. On emulators, </span><span class="c11">SR</span><span class="c0">A</span><span class="c11">M</span><span class="c0">&nbsp;is stored in the well-known .</span><span class="c11">srm</span><span class="c0">&nbsp;files.</span><hr style="page-break-before:always;display:none;"></p><h4 class="c43 c22" id="h.ti3bj41nhldk"><span class="c0 c18">Chapter 6: General registers </span><span class="c15 c0">Important</span></h4><p class=""><span class="c0">In SNES, there are several </span><span class="c0">&ldquo;</span><span class="c0">registers</span><span class="c0">&rdquo;</span><span class="c0">&nbsp;used for different purposes. They can not be missed; they&rsquo;re one of the reasons why the SNES can function properly. Basically, </span><span class="c0">r</span><span class="c0">egisters are </span><span class="c0">&ldquo;</span><span class="c0">global variables</span><span class="c0">&rdquo;</span><span class="c0">&nbsp;which hold various information, or can be used for math and logic and all those fancy stuff! </span><span class="c0">These registers</span><span class="c0">&nbsp;can be accessed anytime.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">Accumulator</span><span class="c0">: Let&rsquo;s just call this &lsquo;A&rsquo;. This register can be accessed in either 8-bit mode or 16-bit mode. A is used for general math, bit shifts, bitwise operations and loading indirect values. A can also hold general-purpose variables to store things to the memory and other registers. </span><span class="c0">In reality, this register is always 16-bits long.</span><span class="c0">&nbsp;When A is in 8-bit mode, you can automatically access these yy digits: $</span><span class="c11">xxyy. </span><span class="c0">You can access the xx AND yy digits when you&rsquo;re in 16-bit mode. The </span><span class="c0">xx digits don&rsquo;t get cleared when A enters 8-bit mode. Certain instructions use all 16 bits of A regardless of 8 or 16-bit mode of the SNES CPU.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">X &amp; Y registers</span><span class="c0">: Also known as X and Y. They are </span><span class="c11">separate</span><span class="c0">&nbsp;registers, and both of them have exactly the same purposes and behave exactly the same: These registers are made for indexing, explained later in this tutorial. These registers can also be 8-bit or 16-bit. X and Y can also hold general-purpose variables to store things to the memory and other registers. When X and Y leave 16-bit mode, their high bytes gets cleared to the number $00. </span><span class="c0">X and Y a</span><span class="c0">re &ldquo;paired&rdquo; &ndash; they can be 8-bit or 16-bit mode </span><span class="c11">only at the same time</span><span class="c0">. One of them can&rsquo;t be 8-bit while the other one is 16-bit.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">Direct page register</span><span class="c0">:</span><span class="c0 c90">&nbsp;</span><span class="c0">It is a 16-bit register. When you use the direct page addressing mode (explained later in this tutorial), it adds the direct page address with the value in the direct page register. If you&rsquo;re a complete beginner, don&rsquo;t worry about this register.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">Stack Pointer Register</span><span class="c0">: This 16-bit register holds the pointer to the stack in the RAM, relative to RAM address $000000. To affect this register you either need to use TXS (in 16-bit XY mode) or TCS. The register dynamically changes, as you push and pull values to the stack (explained later in the tutorial).</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">Processor status register</span><span class="c0">: This holds the current processor flags&rsquo; status in 8-bit format. Remember that there are 8 processor flags, and they all occupy one bit. Changing this register would alter the SNES behaviour greatly. Processor flags are explained later in this tutorial.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">Data bank register</span><span class="c0">: This holds the current data bank. When you load something using absolute addressing (see next chapter), the instruction will use this register to determine the loaded location&rsquo;s bank. This 8-bit register</span><span class="c0">&nbsp;can only be changed explicitly.</span><span class="c0">&nbsp;In other words, you will have to </span><span class="c0">change </span><span class="c0">it yourself using various opcodes, since it doesn&rsquo;t happen automatically.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">Program bank register</span><span class="c0">: This register keeps track of the current bank of the currently executed instruction. So if there is a code executed at bank $02, this register will hold the value $02. This register is always updated.</span></p><p class="c13"><span class="c0"></span></p><p class="c5"><span class="c11">Program Counter</span><span class="c0">: This register keeps track of the current high and low bytes of the currently executed instruction. So if there is an instruction executed at $018009, this register will hold $8009 as its value. This register is always updated.</span><hr style="page-break-before:always;display:none;"></p><h4 class="c22" id="h.wq2no7e7mnoi"><span class="c0 c18">Chapter 7: Addressing modes &amp; other names </span><span class="c15 c0">&nbsp;Important</span></h4><p class="c22"><span class="c11">NOTE: Prior to reading this chapter, please make sure you understand chapter 4 first!</span></p><p class="c13"><span class="c11"></span></p><p class=""><span class="c0">There are different </span><span class="c32 c0">addressing modes</span><span class="c0">&nbsp;in 65c816. Addressing modes are used to make the </span><span class="c0">opcodes </span><span class="c0">access data and memory differently, such as indexed or direct indirect (explained later in this tutorial). Using them wisely, you can access data and memory in many ways. </span><span class="c0">For example</span><span class="c0">, you can immediately load a value in some register such as A, X or Y, or </span><span class="c0">load a byte from the ROM into</span><span class="c0">&nbsp;memory, and so on. Keep in mind that not all the opcodes supports all the types of addressing modes. Here are some of the </span><span class="c11">important</span><span class="c0">&nbsp;addressing modes</span><span class="c0">&nbsp;you&rsquo;ll find yourself use very often.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">Immediate 8/16</span><span class="c11 c77">&nbsp;</span><span class="c11">bit: #$XX (or #$XXXX)</span></p><p class=""><span class="c0">This addressing mode </span><span class="c0">defines</span><span class="c0">&nbsp;an absolute value. The # stands for &lsquo;immediate&rsquo;</span><span class="c0">, while the $ stands for hexadecimal.</span><span class="c0">&nbsp;# solely makes the input decimal (gets converted to hexadecimal automatically by the assembler), adding a </span><span class="c0">$</span><span class="c0">&nbsp;(so, #$) makes the input hexadecimal. For example, </span><span class="c11">#10</span><span class="c0">&nbsp;is the same as </span><span class="c11">#$0A</span><span class="c0">. </span><span class="c0">Think of an absolute value as a number. Yes, that&rsquo;s really it.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">Direct page:</span><span class="c0">&nbsp;This</span><span class="c0">&nbsp;addressing mode defines a </span><span class="c0">direct page address, $XX</span><span class="c0">.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">The direct page is the last 2 hex digits of a complete (long) address: $XX:XX</span><span class="c11">XX</span><span class="c0">, for example, $7E00</span><span class="c11">11</span><span class="c0">&nbsp;as direct page would be $11</span><span class="c0">. When loading from a direct page address, the </span><span class="c11">bank</span><span class="c0">&nbsp;byte is </span><span class="c0 c29">ALWAYS</span><span class="c0">&nbsp;treated as $00.</span><span class="c0">&nbsp;If you do &ldquo;LDA $11&rdquo; for example, you would load the contents of $000011 into the accumulator, which is also mirrored at $7E0011 (remember the illustration of the SNES memory from earlier). So you load $7E0011&rsquo;s contents.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">Absolute:</span><span class="c0">&nbsp;This </span><span class="c0">addressing mode defines </span><span class="c0">an absolute address, $XXXX</span><span class="c0">.</span><span class="c0">&nbsp;</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">An absolute address is the last 4 hex digits of a complete address: $XX:</span><span class="c11">XXXX</span><span class="c0">. The bank is determined by the </span><span class="c11">data bank register</span><span class="c0">&nbsp;(see previous chapter).</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">Long:</span><span class="c0">&nbsp;This </span><span class="c0">addressing mode defines a long address</span><span class="c0">, $XX:XXXX.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Long addresses deliver fewer complications when dealing with banks and all those </span><span class="c0">things, because you don&rsquo;t have to worry about what the data bank register contains for example</span><span class="c0">. With long addresses, you can access </span><span class="c11">any</span><span class="c0">&nbsp;offset in the SNES memory.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">There are also indexed versions of direct page, absolute and long addresses, and much more&hellip; They will be explained near the end of this document because you don&rsquo;t need them at this point in the tutorial. It would make things only more confusing at the moment.</span></p><p class="c13"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><h4 class="c43 c22" id="h.op6c9hbjmn8r"><span class="c18 c11">Chapter 8: Little Endian</span></h4><p class=""><span class="c0">In the ROM, RAM and SRAM, 16-bit and 24-bit values always appear in </span><span class="c11">little-endian</span><span class="c0">. Take for example, we use an opcode which uses $1234 as its parameter. The opcode ends up in the ROM, as well as the number $1234. However, $1234 doesn&rsquo;t appear as $1234. It appears as $34 $12 in the ROM. It</span><span class="c0">&rsquo;s because hexadecimal bytes are stored backwards like that, which is called little-endian.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">When this number is read in 16-bit mode, it reads $1234, NOT $3412. The SNES reverses this automatically again. If this number is read into the RAM, it is stored as $34 $12, much like in the ROM.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">24-bits numbers such as $123456 are stored in the ROM as $56 $34 $12. You could try to read this into the RAM, but the SNES cannot read 24-bit values directly into a register such as A, X and Y to begin with!</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">You can write everything in normal ASM without worrying about little-endian, because everything is dealt with automatically! </span><span class="c0">You can worry about little-endian when you deal with 16-bit values in 8-bit mode, for example: You&rsquo;re trying to access the value </span><span class="c11">$00</span><span class="c0">&nbsp;in RAM </span><span class="c11">$7E0000</span><span class="c0">. The value </span><span class="c11">$0011</span><span class="c0">&nbsp;was stored there earlier, so </span><span class="c11">$7E0001 is involved</span><span class="c0">&nbsp;</span><span class="c11">too</span><span class="c0">. </span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">In this case: RAM </span><span class="c11">$7E0000</span><span class="c0">&nbsp;contains the value </span><span class="c11">$11</span><span class="c0">, and </span><span class="c11">$7E0001</span><span class="c0">&nbsp;contains the value </span><span class="c11">$00</span><span class="c0">. A common mistake is that people try to access $7E0000 here! The actual RAM address you need to access is $7E0001. This is where little-endian might get very confusing.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">If you don&rsquo;t understand this chapter at first, don&rsquo;t worry. It isn&rsquo;t that important, but it is essential when dealing with &ldquo;pointers&rdquo;. Feel free to revisit this chapter sometime later in the tutorial.</span></p><hr style="page-break-before:always;display:none;"><h4 class="c43 c22" id="h.zfpotxk7c096"><span class="c18 c11">Chapter 9: Loading and Storing</span></h4><p class=""><span class="c11">You&rsquo;ve made it to the opcodes section.</span><span class="c0">&nbsp;Congratulations! The first thing you definitely should know is how to load and store data </span><span class="c0">using various SNES registers</span><span class="c0">. The basic opcodes for </span><span class="c0">loading and storing data are</span><span class="c0">&nbsp;</span><span class="c32 c0">LDA</span><span class="c0">&nbsp;and </span><span class="c32 c0">STA</span><span class="c0">. </span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">You will get 3 registers to work with. They are: A (Accumulator). Y (Call it Y) and X (Call it X). </span><span class="c0">Although these registers can be either in 8 or 16-bit mode, </span><span class="c11">i</span><span class="c11">n this tutorial we will consider them 8-bit by default.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">Here is our very first two opcodes:</span></p><p class="c5 c70"><span class="c11 c19">LDA - </span><span class="c0">LoaD into Accumulator</span></p><p class="c5 c70"><span class="c11 c19">STA</span><span class="c0 c19">&nbsp;- </span><span class="c0">STore from Accumulator</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">Opcode </span><span class="c0">LDA </span><span class="c0">loads a value in A, and </span><span class="c0">STA </span><span class="c0">stores A into a</span><span class="c0">n</span><span class="c0">&nbsp;address. We will use RAM addresses </span><span class="c0">for the sake of simplicity</span><span class="c0">.</span><span class="c0">&nbsp;</span><span class="c0">Here is a short example for loading and storing:</span></p><p class="c13"><span class="c44 c0 c19"></span></p><a id="t.32c7b3e405e3b09d919440f935990e011c20f1ba"></a><a id="t.3"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$03 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; A = $03</span></p><p class="c5"><span class="c10 c0">STA $7E0001</span></p></td></tr></tbody></table><p class="c13"><span class="c11"></span></p><p class=""><span class="c0">Let&rsquo;s break </span><span class="c0">this </span><span class="c0">down</span><span class="c0">&nbsp;and look into it bit by bit!</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">LDA #$03</span></p><p class="c13"><span class="c11"></span></p><p class=""><span class="c0">This loads the number $03 into A. The contents of the A register is now $03. LDA can load numbers ranging from #$00-#$FF in 8-bit mode and #$0000-#$FFFF in 16-bit mode.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">STA $7E0001</span></p><p class="c13"><span class="c11"></span></p><p class=""><span class="c0">This stores the contents of the A register into RAM address $7E0001. RAM Address $7E0001 now contains the number $03, because A was $03 too. The contents of the A register </span><span class="c0">is </span><span class="c11">not</span><span class="c0">&nbsp;cleared</span><span class="c0">. Therefore, A remains $03.</span><span class="c0">&nbsp;This is useful in case you want to store this same value into multiple addresses.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Also,</span><span class="c0">&nbsp;for the love of </span><span class="c0">G</span><span class="c0">od, please don&rsquo;t use STA #$7E0001 or any form of STA #$ because that doesn&rsquo;t exist. There is no logic behind </span><span class="c0">storing the value of A into an absolute value.</span></p><p class="c13"><span class="c0"></span></p><a id="t.06696ce6e64afbc9a6c8a059cbd9d8062f8fa2e8"></a><a id="t.4"></a><table class="c16"><tbody><tr class="c6"><td class="c41" colspan="1" rowspan="1"><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 161.00px; height: 17.00px;"><img alt="" src="images/image00.png" style="width: 161.00px; height: 17.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c6"><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c0 c57">Remember, using $ instead of #$ after an opcode means that the parameter is an </span><span class="c11 c57">address</span><span class="c45 c0">, not an immediate value.</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">On a side note: Putting a semicolon (;) </span><span class="c0">w</span><span class="c0">ill allow </span><span class="c0">everything beyond that</span><span class="c0">&nbsp;to be ignored by the assembler, during the assembly of the code. In </span><span class="c0">other words, ; is used to place comments.</span><span class="c0">&nbsp;Example:</span></p><p class="c5 c13"><span class="c0"></span></p><a id="t.cc2d377b397b9bc133b868c9c6e5cebeec5d6c65"></a><a id="t.5"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c10 c0">LDA #$03&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;This is a comment!</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c0 c93"></span></p><p class="c5"><span class="c0">Of course, what would be the use to store things to a RAM address when you don&rsquo;t know how to access </span><span class="c0">the address</span><span class="c0">&nbsp;again? You can load a RAM address&rsquo; contents into the A register by using LDA again. Here is an example.</span></p><p class="c13"><span class="c44 c0 c19"></span></p><a id="t.2e6ef03c1d33631d5a9e0f77a368df19f93a34b5"></a><a id="t.6"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $7E0069</span></p><p class="c5"><span class="c10 c0">STA $7E0042</span></p></td></tr></tbody></table><p class="c13"><span class="c11"></span></p><p class=""><span class="c0">Again, we will break this down!</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">LDA $7E0069</span></p><p class="c13"><span class="c11"></span></p><p class=""><span class="c0">This will load the contents of the RAM address $7E0069 into A. Let&rsquo;s assume that the contents were $33. So now, A has the number $33, what about the RAM address $7E00</span><span class="c0">42</span><span class="c0">? It will remain unchanged because we haven</span><span class="c0">&rsquo;t reached that code yet</span><span class="c0">. W</span><span class="c0">hat about $7E0069? It also remains unchanged, because LDA copies the number rather than extracting it from the address.</span><span class="c0">&nbsp;</span><span class="c0">Note that this time we have used $ instead of #$. This is because we wanted to access a RAM address.</span><span class="c0">&nbsp;In the </span><span class="c0">end, A has $33 and RAM $7E0069 has $33 too.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">STA $7E0042</span></p><p class="c13"><span class="c11"></span></p><p class=""><span class="c0">So we have reached this code. </span><span class="c0">This instruction will store the contents of the A register into the RAM address $7E0042. Of course, A will remain unchanged. RAM address $7E0042 is now $33. </span><span class="c0">In short:</span><span class="c0">&nbsp;this code will copy the contents of $7E0069 over to $7E0042</span><span class="c0">.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Now that we have learned the basics of loading and store values into addresses, let&rsquo;s introduce four new opcodes:</span></p><p class="c70"><span class="c11 c19">LDY - </span><span class="c0">LoaD into Y</span></p><p class="c70"><span class="c11 c19">STY</span><span class="c0 c19">&nbsp;- </span><span class="c0">STore from Y</span></p><p class="c70"><span class="c11 c19">LDX - </span><span class="c0">LoaD into X</span></p><p class="c70"><span class="c11 c19">STX</span><span class="c0 c19">&nbsp;- </span><span class="c0">STore from X</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">The above opcodes behave exactly like LDA and STA. The only difference is that these make use of the X and the Y registers instead of the accumulator.</span><span class="c0">&nbsp;For example:</span></p><p class="c13"><span class="c10 c0"></span></p><a id="t.5875de66abf98301a72e382183bdb1e09585c9a2"></a><a id="t.7"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDY #$03</span></p><p class="c5"><span class="c3 c0">STY $0001</span></p></td></tr></tbody></table><p class="c13"><span class="c11"></span></p><p class=""><span class="c0">Would store the number $03 into RAM address $7E0001, by utilizing the Y register. To use the X register, use </span><span class="c11">LDX</span><span class="c0">&nbsp;and </span><span class="c11">STX</span><span class="c0">. </span><span class="c0">As for why I have used $0001 instead of $7E0001, see the end of the chapter for an explanation.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">You can&rsquo;t do the following:</span></p><p class="c13"><span class="c10 c0"></span></p><a id="t.4df67b354c75ca0d661a5c8669c914e5688fc570"></a><a id="t.8"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDY #$03</span></p><p class="c5"><span class="c3 c0">STA $0001</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Actually, you can, but you wouldn&rsquo;t get the result you expected. If you did this, it would load number $03 into </span><span class="c11">Y</span><span class="c0">, and store whatever is in </span><span class="c11">A</span><span class="c0">&nbsp;into RAM $7E0001.</span></p><p class=""><span class="c0">There is another opcode which stores the number $00 into addresses directly:</span></p><p class="c70"><span class="c11 c19">STZ - </span><span class="c0">STore Zero to memory</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Basically, this opcode stores the number $00 in</span><span class="c0">to an address</span><span class="c0">. </span><span class="c0">It doesn&rsquo;t even need the A, X or Y registers to load $00 first.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">If you want to make a code that directly stores $00 in a RAM address, you could make it use 1 line:</span></p><p class="c13"><span class="c10 c0"></span></p><a id="t.c6b8eddb81bc3fb02e49055f783df6a5426f9120"></a><a id="t.9"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">STZ $01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; $7E0001 = $00. The A register is unaffected.</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">STZ will store zero to a RAM address specified. After this opcode, RAM address $7E0001 will now contain the number $00. For now, don&rsquo;t wonder why I shortened $7E0001 down to $01. I will explain that in the end of this chapter. Using STZ when A is in 16-bit mode will store $0000 to RAM address $7E0001 and $7E0002.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Okay, so (hopefully) you understand how loading and storing values works now. But those were only 8-bit values. There are times where you will need to use 16-bit values. This is the part where you will get confused, because this time you will involve 2 RAM addresses at the same time during loading and storing. Let&rsquo;s start from the beginning again, but in 16-bit A mode this time!</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">In 16-bit A mode, the following features take effect:</span></p><ul class="c53 lst-kix_list_3-0 start"><li class="c31"><span class="c0">During r</span><span class="c0">eading from the memory</span><span class="c0">, you will involve 2 RAM addresses as opposed to 1.</span></li><li class="c31"><span class="c0">The RAM addresses </span><span class="c0">involved are always adjacent </span><span class="c0">to each other.</span></li><li class="c31"><span class="c0">Above 2 features goes for </span><span class="c0">writing</span><span class="c0">&nbsp;to the memory too.</span></li><li class="c31"><span class="c0">Constant numbers (#$) are now 16-bit numbers.</span></li><li class="c5 c31"><span class="c0">Loaded and stored values</span><span class="c0">&nbsp;are</span><span class="c0">&nbsp;little-endian in the memory, but you don&rsquo;t have to worry about that at all.</span></li></ul><p class="c5 c13"><span class="c0"></span></p><p class=""><span class="c0">Let&rsquo;s begin with an example immediately:</span></p><p class="c13"><span class="c44 c0 c19"></span></p><a id="t.7f8ab1a2e669e222dfb0ed73d45ec6198bfcbaad"></a><a id="t.10"></a><table class="c16"><tbody><tr class="c6"><td class="c59" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$0001</span></p><p class="c5"><span class="c10 c0">STA $7E0000</span></p></td></tr></tbody></table><p class="c13"><span class="c11"></span></p><p class=""><span class="c0">And breaking it down:</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">LDA #$0001</span></p><p class="c13"><span class="c11"></span></p><p class=""><span class="c0">This will load a 16-bit value into A. So A has now number $0001. If this wasn&rsquo;t a 16-bit number, the game would interpret the opcode wrong and most-likely crash the game! This is because the game expect</span><span class="c0">s</span><span class="c0">&nbsp;a </span><span class="c0">16-bit parameters, but you only give it an 8-bit one. The game therefore takes the next opcode as part of the 16-bit parameters causing the following opcodes to become bogus.</span></p><hr style="page-break-before:always;display:none;"><p class="c13"><span class="c0"></span></p><p class="c13"><span class="c0"></span></p><a id="t.e9a92ad38153eec7fe33c75e6e11f23d32604ed3"></a><a id="t.11"></a><table class="c16"><tbody><tr class="c6"><td class="c41" colspan="1" rowspan="1"><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 161.00px; height: 17.00px;"><img alt="" src="images/image00.png" style="width: 161.00px; height: 17.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c6"><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c45 c0">Each opcode (disregarding the parameters) becomes an 8-bit number when assembled. This is why you only see hexadecimal numbers when you open a ROM in a hex editor. To disassemble numbers into ASM code, you&rsquo;ll need to use a &ldquo;disassembler&rdquo;.</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">STA $7E0000</span></p><p class="c13"><span class="c11"></span></p><p class=""><span class="c0">This will store the 16-bit A value into the RAM address $7E0000 AND $7E0001. Why </span><span class="c0">two</span><span class="c0">&nbsp;addresses? Because a 16-bit number won&rsquo;t fit into an </span><span class="c0">address. Remember that an address represents an 8-bit value, so two addresses represent 16-bit</span><span class="c0">. $7E0000 will now have the number $0001.</span><span class="c0">&nbsp;</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Executing these 2 instructions, i</span><span class="c0">f we take a peek into the RAM, we see this:</span></p><p class=""><span class="c11">$7E0000 </span><span class="c7">[01] [00] [XX] [XX] [XX] [&hellip;]</span></p><p class="c13"><span class="c7"></span></p><p class=""><span class="c0">The first green number is the number of RAM address $7E0000, second one belongs to $7E0001, third one belongs to $7E0002, etc. As you can see, RAM is just a </span><span class="c0">range </span><span class="c0">of bytes.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">As you can see, the stored number became little endian. If we try to load it back into A, we would have to use</span><span class="c11">&nbsp;LDA $7E0000</span><span class="c0">. It would load the number $0001 into A again IF A is in 16-bit mode. If you tried to load it back when A was in 8-bit mode it would load the number $01 into A instead</span><span class="c0">.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">There&rsquo;s a 16-bit X and Y mode too. This is not related to 16-bit A mode at all. So if A is 8-bit mode and XY are 16-bit mode, the following </span><span class="c0">is definitely possible</span><span class="c0">:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.0ce967813a8d1c8663165bf91660ac5f2ada4fa0"></a><a id="t.12"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$69</span></p><p class="c5"><span class="c10 c0">LDX #$1337</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">Remember how</span><span class="c0">&nbsp;I&rsquo;ve shortened a</span><span class="c0">&nbsp;RAM</span><span class="c0">&nbsp;address down to 4 and even 2 digits earlier when I was</span><span class="c0">&nbsp;</span><span class="c0">demonstrating STZ</span><span class="c0">?</span><span class="c0">&nbsp;It&rsquo;s possible to shorten down addresses indeed. But there are prerequisites. </span></p><p class="c13"><span class="c0"></span></p><p class="c5"><span class="c0">In order to shorten a long RAM address into a 4-digits address, </span><span class="c0">the address has to be between $7E0000-$7E1FFF. $7E1234 can be shortened to $1234 for example. If you shorten address $7E2000 or higher into a 4-digit address, you&rsquo;ll write to areas other than the RAM. It has to do with the data bank register and the memory map explained in the previous chapters.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">If you want to shorten long RAM addresses to a 2-digit address, the high and low bytes of the long address must never exceed the number $00FF. The address you want to store to must be in bank $00 or $7E. So you can shorten LDA $7E0001 to LDA $01 and STA $000001 to STA $01. Keep in mind that when you use 2 digits for loading and storing, the bank is always $00 by default, regardless of the data bank! This </span><span class="c0">means you can use 2-digit addresses for RAM addresses $7E0000-$7E00FF. Remember, RAM $7E0000-$7E1FFF is mirrored in banks $00-$3F by default.</span></p><h4 class="c43 c22" id="h.pmhjv25ylybj"><span class="c18 c11">Chapter 10: Branching, </span><span class="c0 c18">L</span><span class="c18 c11">abels and Comparing</span></h4><p class=""><span class="c0">What if you want to </span><span class="c0">execute</span><span class="c0">&nbsp;special code when certain conditions are met? You need to use branching, labels, and comparing for this.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Now introducing an opcode to compare values inside the Accumulator:</span></p><p class="c9"><span class="c11 c19">CMP - </span><span class="c0">CoMPare A with</span></p><p class="c13"><span class="c0"></span></p><p class="c5"><span class="c0">CMP</span><span class="c0">&nbsp;takes whatever is in A, and compares it with a specified </span><span class="c0">parameter</span><span class="c0">. After using a CMP instruction, you need to use an opcode that will perform the type of </span><span class="c0">&ldquo;</span><span class="c0">branch</span><span class="c0">&rdquo;</span><span class="c0">&nbsp;that you wish to occur. </span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">One example of a branch:</span></p><p class="c5 c9"><span class="c11 c19">BEQ - </span><span class="c0">Branch if EQual</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">BEQ</span><span class="c0">&nbsp;branches if the compared value is equal to the contents of A:</span></p><p class="c13"><span class="c44 c0 c19"></span></p><a id="t.a0fc7ff35412f4d7df36316e7f8af07944218050"></a><a id="t.13"></a><table class="c16"><tbody><tr class="c6"><td class="c59" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Loads the current value of RAM address $7E0000 into A</span></p><p class="c5"><span class="c3 c0">CMP #$02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Compares A with the absolute number $02</span></p><p class="c5"><span class="c10 c0">BEQ </span><span class="c28 c0 c19">Label1</span><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; If A = $02, go to the codes in Label1. NOTE: Case-Sensitive</span></p><p class="c5"><span class="c3 c0">LDA #$01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; \Else</span></p><p class="c5"><span class="c0 c3">STA $1245&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; /Store number $01 into RAM $7E1245.</span></p><p class="c5"><span class="c3 c0">RTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; This instruction is used to end a routine.</span></p><p class="c5"><span class="c28 c0 c19">Label1:</span><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;</span></p><p class="c5"><span class="c3 c0">STZ $19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Store zero in $7E0019</span></p><p class="c5"><span class="c10 c0">RTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; End.</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">This code is a bit big to break it down, so I will summarize it. This code will store zero ($00) in $7E0019 when $7E0000 has the number $02 as its content. And if it has NOT $02 as its content, </span><span class="c0">the code</span><span class="c0">&nbsp;will store number $01 in $7E1245. BEQ will jump to a portion of the code when compared </span><span class="c0">values</span><span class="c0">&nbsp;are equal, skipping </span><span class="c0">certain </span><span class="c0">code </span><span class="c0">a bit</span><span class="c0">! In this case, </span><span class="c0">the game</span><span class="c0">&nbsp;jumps to the code at &ldquo;Label1&rdquo;</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Labels are basically text placed to locate an entry point of a jump or a </span><span class="c0">&ldquo;</span><span class="c0">table</span><span class="c0">&rdquo;</span><span class="c0">. </span><span class="c0">Labels are no </span><span class="c0">opcodes or anything. It&rsquo;s basically an easier way to specify an offset/address</span><span class="c0">, because the labels get turned into numbers by the assembler.</span><span class="c0">&nbsp;It is good practice to not name labels after opcodes. Give them </span><span class="c0">meaningful names instead for your own sake.</span></p><p class="c13"><span class="c0"></span></p><p class="c13"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Another example of a branch:</span></p><p class="c9"><span class="c11 c19">BNE - </span><span class="c0">Branch if Not Equal</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">BNE</span><span class="c0">&nbsp;is the opposite of </span><span class="c0">BEQ</span><span class="c0">. It </span><span class="c0">branches </span><span class="c0">when the value does NOT match with A:</span></p><p class="c13"><span class="c44 c0 c19"></span></p><a id="t.5a2e55982a1caed7032f2e5e0039a7324922ee35"></a><a id="t.14"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Loads the current value of RAM address $7E0000 into A</span></p><p class="c5"><span class="c3 c0">CMP #$02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Compares A with $02</span></p><p class="c5"><span class="c10 c0">BNE </span><span class="c28 c0 c19">Label1</span><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; A = NOT $02, finish the code, do nothing.</span></p><p class="c5"><span class="c3 c0">LDA #$01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; \Else</span></p><p class="c5"><span class="c3 c0">STA $1245&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; /Store something in RAM $7E1245</span></p><p class="c5"><span class="c28 c0 c19">Label1:</span><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;</span></p><p class="c5"><span class="c10 c0">RTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; End.</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">So, if RAM address $7E0000 has the </span><span class="c0">value </span><span class="c0">$02, the code will store the </span><span class="c0">value </span><span class="c0">$01 to RAM address $7E1245. If RAM address $7E0000 doesn&rsquo;t have the </span><span class="c0">value </span><span class="c0">$02, the code will do absolutely nothing.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">I</span><span class="c0">t&rsquo;s also possible to compare 16-bit numbers. Just change CMP #$xx to CMP #$xxxx.</span></p><p class=""><span class="c0">Furthermore</span><span class="c0">, you can compare RAM addresses with each other too. See the next example:</span></p><p class="c13"><span class="c11"></span></p><a id="t.23d364e07cf3e80a1ee849a50683c86ae783368d"></a><a id="t.15"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $00</span></p><p class="c5"><span class="c3 c0">CMP $02</span></p><p class="c5"><span class="c10 c0">BEQ Equal</span></p></td></tr></tbody></table><p class="c13"><span class="c11"></span></p><p class=""><span class="c0">When RAM addresses $7E0000 and $7E0002 have the same numbers, the branch will be taken.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">You can also compare values by using the registers X and Y:</span></p><p class="c9"><span class="c11 c19">CPX - </span><span class="c0">ComPare X with</span></p><p class="c9"><span class="c11 c19">CPY - </span><span class="c0">ComPare Y with</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">For example, you can load a value into X and compare it with a number. Not only A is capable of doing </span><span class="c0">comparisons</span><span class="c0">. Example:</span></p><p class="c13"><span class="c11"></span></p><a id="t.10f9f4da76111604910358e2fb646c3389142848"></a><a id="t.16"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDX $00</span></p><p class="c5"><span class="c3 c0">CPX $02</span></p><p class="c5"><span class="c10 c0">BEQ Equal</span></p></td></tr></tbody></table><p class="c13"><span class="c11"></span></p><p class=""><span class="c0">It will have the same result as the above example. You can compare register Y too by using </span><span class="c0">CPY</span><span class="c0">. However, </span><span class="c0">the following </span><span class="c0">is wrong:</span></p><p class="c13"><span class="c44 c0 c19"></span></p><a id="t.d1cc051d0a8681229195fb238b08d836a184226f"></a><a id="t.17"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDX $00</span></p><p class="c5"><span class="c3 c0">CMP $02</span></p><p class="c5"><span class="c10 c0">BEQ Equal</span></p></td></tr></tbody></table><p class="c13"><span class="c11"></span></p><p class=""><span class="c11">CMP $02</span><span class="c0">&nbsp;would try to compare register $7E0002 with the register A, instead of X.</span><span class="c0">&nbsp;The comparison will be bogus, and the branch would have unwanted effects.</span></p><hr style="page-break-before:always;display:none;"><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Some other misc</span><span class="c0">ellaneous</span><span class="c0">&nbsp;branching opcodes are the following 8 branches. They are divided in 4 groups:</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">S</span><span class="c0">igned branching:</span></p><p class=""><span class="c0 c29">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">BMI - </span><span class="c0">Branch if MInus</span></p><p class=""><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">BPL - </span><span class="c0">Branch if PLus</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">BMI </span><span class="c0">branches if the last operation is a minus/negative value. Minus values are the numbers $80-$FF.</span></p><p class="c13"><span class="c32 c0"></span></p><p class=""><span class="c0">BPL </span><span class="c0">branches if the last operation is not a minus value; Branch when number $00-$7F</span></p><p class="c13"><span class="c0 c29"></span></p><p class=""><span class="c0">Greater or lesser and/or Carry flag</span><span class="c0">:</span></p><p class=""><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">BCS - </span><span class="c0">Branch if Carry Set</span></p><p class=""><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">BCC - </span><span class="c0">Branch if Carry Clear</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">BCS </span><span class="c0">branches if </span><span class="c0">the loaded value is </span><span class="c32 c0">e</span><span class="c32 c0">qual or greater</span><span class="c0">&nbsp;than the compared value. Additionally, this a</span><span class="c0">lso </span><span class="c0">branches when the carry flag is set.</span></p><p class="c13"><span class="c0 c32"></span></p><p class=""><span class="c0">BCC branches if the loaded value is lesser than the compared value. </span><span class="c0">Additionally, this also branches when the carry flag is clear. </span><span class="c0">Please note that this branch doesn&rsquo;t get taken if the compared value is equal, unlike BCS.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Overflow flag:</span></p><p class=""><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">BVC - </span><span class="c0">Branch if oVerflow Clear</span></p><p class=""><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">BVS - </span><span class="c0">Branch if oVerflow Set</span></p><p class="c13"><span class="c32 c0"></span></p><p class=""><span class="c0">BVC </span><span class="c0">branches if the overflow flag is clear.</span></p><p class=""><span class="c0">BVS </span><span class="c0">branches if the overflow flag is set.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">The &ldquo;overflow&rdquo; flag is a processor flag, explained later in the tutorial.</span></p><p class="c13"><span class="c0 c29"></span></p><p class=""><span class="c0">Unconditionals:</span></p><p class=""><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">BRA - </span><span class="c0">BRanch Always</span></p><p class=""><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">BRL - </span><span class="c0">BRanch always Long</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">BRA </span><span class="c0">will ALWAYS branch, </span><span class="c0">it doesn&rsquo;t even check for conditions.</span></p><p class=""><span class="c0">BRL </span><span class="c0">does</span><span class="c0">&nbsp;the same, but it has a longer </span><span class="c0">reach for labels. They&rsquo;re pretty much like JMPs. Useful if your code executes in RAM, because its branch destination is relative.</span></p><p class="c13"><span class="c0"></span></p><a id="t.27945af1cc89254123eb30f5b8beda6a73d217a2"></a><a id="t.18"></a><table class="c16"><tbody><tr class="c6"><td class="c41" colspan="1" rowspan="1"><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 161.00px; height: 17.00px;"><img alt="" src="images/image00.png" style="width: 161.00px; height: 17.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c6"><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c0 c57">The branching opcodes have a range of -128 to 127 bytes. This means they can either jump 128 bytes backwards, or they can jump 127 bytes forward, relative to the program counter. One exception is </span><span class="c32 c0 c57">BRL</span><span class="c0 c57">&nbsp;(Branch Long). </span><span class="c32 c0 c57">BRL</span><span class="c45 c0">&nbsp;has a range of 32768 bytes (8000 in hex), which is a WHOLE bank. If the branch goes out of range, you&rsquo;ll have to find a way to put the destination label into the branch&rsquo;s reach. The tips and tricks chapter covers this. A branch out of reach is called &ldquo;branch out-of-reach error&rdquo; by various assemblers. </span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class="c13"><span class="c0"></span></p><h4 class="c43 c22" id="h.99uk38ge9rel"><span class="c0 c18">Chapter 11: Jumping to (sub)routines</span></h4><p class=""><span class="c0">What if you want to use the same code twice, but you don&rsquo;t want to write, for example, the exact</span><span class="c0">&nbsp;same</span><span class="c0">&nbsp;200 lines of codes again? You</span><span class="c0">&nbsp;will </span><span class="c0">make use of the jumping opcodes to jump to the code you want to use. </span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">There are </span><span class="c0">two </span><span class="c0">jumping opcodes:</span></p><p class=""><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">JSR - </span><span class="c0">Jump to SubRoutine</span></p><p class=""><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">JSL - </span><span class="c0">Jump to Subroutine Long</span></p><p class="c13"><span class="c0"></span></p><p class="c5"><span class="c0">You can consider JSR and JSL as function calls basically</span><span class="c0">. </span><span class="c0">Here is a quick example of the usage of JSR:</span></p><p class="c13"><span class="c0"></span></p><a id="t.2ed3222a3a11babe6a12701caca3d7495d3b30b6"></a><a id="t.19"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$01</span></p><p class="c5"><span class="c3 c0">STA $01</span></p><p class="c5"><span class="c3 c0">JSR Label1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Execute the &ldquo;subroutine&rdquo; located at Label1 (current bank)</span></p><p class="c5"><span class="c3 c0">LDA #$03&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;The RTS in Label1 will return to this line</span></p><p class="c5"><span class="c3 c0">STA $00</span></p><p class="c5"><span class="c3 c0">RTS</span></p><p class="c5 c13"><span class="c3 c0"></span></p><p class="c5"><span class="c3 c0">Label1:</span></p><p class="c5"><span class="c3 c0">LDA #$02</span></p><p class="c5"><span class="c3 c0">STA $02</span></p><p class="c5"><span class="c10 c0">RTS</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">This code will store $01 into $7E0001, will store $03 into $7E0000 AND execute the codes at Label1 at the current bank, so store $02 into $7E0002.</span></p><p class="c13"><span class="c0"></span></p><a id="t.e3a7fb0e692cbed37a385d204c887014d99bf4df"></a><a id="t.20"></a><table class="c16"><tbody><tr class="c6"><td class="c41" colspan="1" rowspan="1"><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 161.00px; height: 17.00px;"><img alt="" src="images/image00.png" style="width: 161.00px; height: 17.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c6"><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c45 c0">The opcode JSR will get assembled as JSR $XXXX by the assembler, but you shouldn&rsquo;t worry about that. Like I said, labels specify an offset. The assembler automatically converts the label into an offset/address. Furthermore, because JSR uses an absolute address as its parameter, it is limited to its current bank.</span></p></td></tr></tbody></table><p class=""><span class="c0">&nbsp;</span></p><p class=""><span class="c0">There is an opcode required to finish a subroutine:</span></p><p class=""><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">RTS - </span><span class="c0">ReTurn from Subroutine</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">The RTS will cause the game to jump back to the opcode after the latest used JSR.</span></p><p class="c13"><span class="c0"></span></p><p class="c5"><span class="c0">JSL has the same </span><span class="c0">purpose as JSR</span><span class="c0">, except it can jump </span><span class="c11">everywhere</span><span class="c0">.</span></p><p class="c5 c13"><span class="c11"></span></p><a id="t.9b1f7e9c1efa3a42fc2b59d94d31080328717eeb"></a><a id="t.21"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$01</span></p><p class="c5"><span class="c3 c0">STA $19</span></p><p class="c5"><span class="c3 c0">JSL $1AFB00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Execute the codes located at ROM address $1AFB00</span></p><p class="c5"><span class="c3 c0">LDA #$03</span></p><p class="c5"><span class="c3 c0">STA $00</span></p><p class="c5"><span class="c10 c0">RTS</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">This code will store the number $01 to RAM address $7E0019, and will execute the code at ROM address $1AFB00. You can select every SNES offset when you use JSL. It is actually pretty simple. After executing the JSL, the code will return to the LDA #$03. Then the code stores the number $03 to RAM address $7E0000.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">JSL uses another opcode to return from the subroutine:</span></p><p class=""><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">RTL - </span><span class="c0">ReTurn from subroutine Long</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">There are two other jumps which do NOT automatically return to the opcode after the jump:</span></p><p class="c5 c9"><span class="c11 c19">JMP - </span><span class="c0">JuMP and </span><span class="c11 c19">JML - </span><span class="c0">JuMp Long</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">JMP and JML will ignore EVERYTHING after the instruction when you use them. Example:</span></p><p class="c5 c13"><span class="c44 c11 c19"></span></p><a id="t.2b357e189a76eaef40a731353684779bc7766001"></a><a id="t.22"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">JML Label1</span></p><p class="c5"><span class="c3 c0">LDA #$03&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Ignored</span></p><p class="c5"><span class="c3 c0">STA $00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Ignored</span></p><p class="c5"><span class="c3 c0">RTS &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Ignored</span></p><p class="c5 c13"><span class="c3 c0"></span></p><p class="c5"><span class="c3 c0">Label1:</span></p><p class="c5"><span class="c3 c0">STZ $00</span></p><p class="c5"><span class="c3 c0">RTS</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">What JMP/JML does is jumping to another location and executes the codes there, ignoring everything after the opcode</span><span class="c0">. The RTS in Label1 does NOT jump back to LDA #$03. Instead, it just finishes the current subroutine it was in.</span></p><p class="c13"><span class="c0"></span></p><p class="c5"><span class="c0">JMP is limited to the current bank, like JSR. It will ignore everything like JML too. JML can jump anywhere like JSL. JMPs and JMLs don&rsquo;t have a return instruction, but you can still use an RTS or RTL to return from a JMP/JMP depending on the current situation. Example:</span></p><p class="c13"><span class="c11"></span></p><a id="t.96ca0e8774bfe6142f1149312360680ae55e2bd2"></a><a id="t.23"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$01</span></p><p class="c5"><span class="c3 c0">STA $00</span></p><p class="c5"><span class="c3 c0">JSR Label1</span></p><p class="c5"><span class="c3 c0">RTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Label2 returns here. The code ends here.</span></p><p class="c5"><span class="c3 c0">Label1:</span></p><p class="c5"><span class="c3 c0">JMP Label2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Absolute jump to Label2</span></p><p class="c5"><span class="c3 c0">Label2:</span></p><p class="c5"><span class="c10 c0">RTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;This DOESN&rsquo;T return to Label1.</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><a id="t.854d8b0650bbe35dcfd069df31a63a4cb1bd662c"></a><a id="t.24"></a><table class="c16"><tbody><tr class="c6"><td class="c41" colspan="1" rowspan="1"><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 161.00px; height: 17.00px;"><img alt="" src="images/image00.png" style="width: 161.00px; height: 17.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c6"><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c45 c0">The Data Bank does NOT get updated when you use a JSL or JML. You will have to do that yourself.</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><a id="t.36c2df75ced7c9815bea2dc884591a6b9801a90f"></a><a id="t.25"></a><table class="c16"><tbody><tr class="c6"><td class="c41" colspan="1" rowspan="1"><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 161.00px; height: 17.00px;"><img alt="" src="images/image00.png" style="width: 161.00px; height: 17.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c6"><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c45 c0">Remember how JSL/JML can jump everywhere? They can even jump to RAM, which implies code can be executed in RAM. It is true! You can write numbers to RAM which can be interpreted as code which can be executed. Not sure if this is practical however.</span></p></td></tr></tbody></table><h4 class="c22" id="h.hkfm12qu7b4r"><span class="c0 c18">Chapter 12: Carry Flag</span></h4><p class=""><span class="c0">The &ldquo;Carry flag&rdquo; is an additional bit used for various </span><span class="c0">things </span><span class="c0">like math, bit-shifting or branching. For example, when the carry flag is set, during addition by </span><span class="c11">ADC</span><span class="c0">&nbsp;(next chapter), an extra 1 gets added. Useful for pseudo 16-bit maths (explained in the tips and tricks chapter). This bit just can&rsquo;t be missed.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">The &ldquo;Carry Flag&rdquo; is basically the &ldquo;9</span><span class="c0 c71">th</span><span class="c0">&nbsp;bit&rdquo; of the A register when A is in 8-bit mode, and the &ldquo;17</span><span class="c0 c71">th</span><span class="c0">&nbsp;bit&rdquo; when A is in 16-bit mode. Assuming A is in 8-bit mode, the carry flag will look like this:</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">BBBBBBBB C</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Where C is the Carry Flag and B is the byte &ndash; in other words the A register content.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">When the carry flag is </span><span class="c0 c29">clear</span><span class="c0">, the carry (C) will be 0</span></p><p class=""><span class="c0">When the carry flag is </span><span class="c0 c29">set</span><span class="c0">, the carry (C) will be 1</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">You can not directly use and change the carry flag by using loading/storing instructions. The carry flag is </span><span class="c11">automatically </span><span class="c0">used and altered by the SNES </span><span class="c0">during </span><span class="c0">various math operations. </span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">There are also two instructions to alter the carry flag directly without loading or storing or calculating anything</span><span class="c0">:</span></p><p class="c9"><span class="c11 c19">SEC - </span><span class="c0">SEt Carry flag</span></p><p class="c9"><span class="c11 c19">CLC - </span><span class="c0">CLear Carry flag</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">To change the carry flag to 1, use </span><span class="c0">SEC.</span></p><p class=""><span class="c0">To change the carry flag to 0, use </span><span class="c0">CLC.</span></p><p class="c13"><span class="c11"></span></p><p class=""><span class="c0">Depending on the carry flag, various mathematical instructions will behave different. You can see it clearly in the next chapter!</span></p><hr style="page-break-before:always;display:none;"><h4 class="c43 c22" id="h.pdluakcmslk4"><span class="c18 c11">Chapter 13: Adding and Subtracting</span></h4><p class=""><span class="c0">At some point, you would probably want to increase RAM address $7E000F by $01, but LDA #$01 STA $7E000F </span><span class="c11">won&rsquo;t</span><span class="c0">&nbsp;work, because it simply changes your RAM Address&rsquo; contents to $01 &ndash; not increase it by one. </span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">There are opcodes to increase or decrease a value by 1:</span></p><p class="c9"><span class="c11 c19">INC - </span><span class="c0">INCrease</span></p><p class="c9"><span class="c11 c19">DEC - </span><span class="c0">DECrease</span></p><p class="c13"><span class="c10 c11"></span></p><a id="t.228347d524d257898958c2aa210abb3470f669d9"></a><a id="t.26"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">INC $0F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Increase the value in $7E000F by one</span></p><p class="c5"><span class="c10 c0">RTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Return</span></p></td></tr></tbody></table><p class="c13"><span class="c44 c11 c19"></span></p><a id="t.eecf84fd83a93c683220481ed39c3543a421114e"></a><a id="t.27"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">DEC $0F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Decrease the value in $7E000F by one</span></p><p class="c5"><span class="c10 c0">RTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c10 c11">; </span><span class="c10 c0">Return</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">When INCing or DECing a </span><span class="c11">RAM Address&rsquo; contents</span><span class="c0">, keep in mind that A</span><span class="c0">&nbsp;does not get affected.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Although, it IS possible to increase or decrease the value inside A, by using </span><span class="c11">INC A</span><span class="c0">&nbsp;or </span><span class="c11">DEC A</span><span class="c0">. In this case, you give &ldquo;A&rdquo; as the parameter instead of an address.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">There are also instructions to increase or decrease the value inside X as well as Y:</span></p><p class="c9"><span class="c11 c19">INX - </span><span class="c0">INcrease X</span></p><p class="c9"><span class="c11 c19">DEX - </span><span class="c0">DEcrease X</span></p><p class="c9"><span class="c11 c19">INY - </span><span class="c0">INcrease Y</span></p><p class="c9"><span class="c11 c19">DEY - </span><span class="c0">DEcrease Y</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">You cannot use the above 4 opcodes to manipulate an address. They are solely used for the X and the Y registers.</span></p><p class="c13"><span class="c0"></span></p><a id="t.12d9db22f65962c95997cbe8b859f99c5f37e618"></a><a id="t.28"></a><table class="c16"><tbody><tr class="c6"><td class="c41" colspan="1" rowspan="1"><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 161.00px; height: 17.00px;"><img alt="" src="images/image00.png" style="width: 161.00px; height: 17.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c6"><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c45 c0">INC and DEC don&rsquo;t work with long addressing modes. They only work with absolute or direct page addressing modes. &nbsp;Therefore, instructions like &ldquo;INC $7E000F&rdquo; do not exist. Instead, you should use INC $000F or even INC $0F.</span></p><p class="c5 c13"><span class="c45 c0"></span></p><p class="c5"><span class="c0 c45">Why there isn&rsquo;t a long addressing mode? Because the engineers made it that way. You&rsquo;ll just have to deal with it.</span></p></td></tr></tbody></table><p class="c13"><span class="c29 c11 c79"></span></p><p class=""><span class="c0">But what if you wanted to increase or decrease the value in a RAM Address by </span><span class="c0">95</span><span class="c0">? You don</span><span class="c0">&rsquo;t want to write INC or DEC 95 times, do you?</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">The solution to above problem are the following four opcodes:</span></p><p class="c9"><span class="c11 c19">ADC - </span><span class="c0">ADd with Carry</span></p><p class="c9"><span class="c11 c19">SBC - </span><span class="c0">SuBtract with Carry</span></p><p class="c9"><span class="c11 c19">SEC - </span><span class="c0">SEt Carry flag</span></p><p class="c9"><span class="c11 c19">CLC - </span><span class="c0">CLear Carry flag</span></p><p class="c9 c13"><span class="c0"></span></p><p class=""><span class="c0">ADC adds a value to the </span><span class="c11">Accumulator</span><span class="c0">, not a RAM address like people mistake it. SBC subtracts it from A.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">To use ADC, you first need to get the value from a RAM address into A, use ADC to change A, then store </span><span class="c0">A</span><span class="c0">&nbsp;back into the RAM Address. Here is a</span><span class="c0">&nbsp;simple</span><span class="c0">&nbsp;example:</span></p><p class="c13"><span class="c44 c0 c19"></span></p><a id="t.8240e3da554b598dc17c64510503665fdf2ab73b"></a><a id="t.29"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $0F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Load the current value in A</span></p><p class="c5"><span class="c3 c0">CLC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Clear Carry Flag</span></p><p class="c5"><span class="c3 c0">ADC #$04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; How many you will add to A. It is $04 in this case.</span></p><p class="c5"><span class="c10 c0">STA $0F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Store A in $0F</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">This will add 4 to the RAM address&rsquo; content. So if it was $35, it would become $39. If you wouldn&rsquo;t clear the carry flag, it would add $05 instead of $04. (Hence Add </span><span class="c11">with</span><span class="c0">&nbsp;Carry)</span></p><p class=""><span class="c0">What if you wanted to decrease a value of a RAM address by $04?</span></p><p class="c13"><span class="c10 c11"></span></p><a id="t.0461a4c8743bd0f47c192ff8db5a4d73ab5c8250"></a><a id="t.30"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $0F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Load the current value in A</span></p><p class="c5"><span class="c3 c0">SEC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Set Carry Flag</span></p><p class="c5"><span class="c3 c0">SBC #$04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; How many you will subtract from A. It is $04 in this case.</span></p><p class="c5"><span class="c10 c0">STA $0F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Store A in $0F</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">This will subtract 4 from the RAM address&rsquo; content. If you didn&rsquo;t set the carry flag, it would subtract $05 instead of $04. In short: when adding, </span><span class="c11">CLC</span><span class="c0">, when subtracting: </span><span class="c11">SEC</span><span class="c0">.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">What is the relation with the carry flag and ADC/SBC, you might wonder.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">W</span><span class="c0">hen you do ADC, and the value in A wraps from $FF </span><span class="c30 c0">&rarr; </span><span class="c0">$00, the carry flag will be set. The same case is in 16-bit A, where you go from $FFFF </span><span class="c30 c0">&rarr; </span><span class="c0">$0000</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">When you do SBC, and the value in A wraps from $00 </span><span class="c30 c0">&rarr; </span><span class="c0">$FF, the carry flag will be cleared. </span></p><p class=""><span class="c0">This is useful for </span><span class="c0">&ldquo;</span><span class="c0">pseudo 16-bit math</span><span class="c0">&rdquo;</span><span class="c0">&nbsp;which will be explained later. The same case is in 16-bit A, where you go from $0000 </span><span class="c30 c0">&rarr; </span><span class="c0">$FFFF</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Adding and subtracting also involves the &ldquo;</span><span class="c0">signed overflow</span><span class="c0">&rdquo;</span><span class="c0">&nbsp;processor flag. To know where this overflow flag is, please visit the </span><span class="c32 c0">in-depth look into processor flags</span><span class="c0">&nbsp;chapter. Overflow happens when you add a negative value to a negative value, and you get a positive value as a result which wouldn&rsquo;t make sense in the math world</span><span class="c0">, and vice versa.</span><span class="c0">&nbsp;See these examples below:</span></p><p class="c13"><span class="c10 c0"></span></p><a id="t.a61512c1d3cf6e253def53d8c53cd38e55e5d3bf"></a><a id="t.31"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$88&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Random negative number</span></p><p class="c5"><span class="c3 c0">CLC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;We add a negative number to another negative number</span></p><p class="c5"><span class="c3 c0">ADC #$F0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = $78. The overflow flag is set, since $78 is a positive value.</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">It&rsquo;s mathematically impossible to gain a positive number from two added negative values, so overflow gets set.</span></p><p class="c13"><span class="c0"></span></p><p class="c13"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Here is an example for SBC:</span></p><p class="c13"><span class="c44 c0 c19"></span></p><a id="t.a78790919148fb3c1014b4f424e341606c790d82"></a><a id="t.32"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Random negative number</span></p><p class="c5"><span class="c3 c0">SEC</span></p><p class="c5"><span class="c3 c0">SBC #$10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;$80 - $10 = $70. Converting these numbers to decimal&hellip;</span></p><p class="c5"><span class="c10 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;-128 &ndash; 16 = 112? Impossible</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">It doesn&rsquo;t make sense! If you subtract something from a negative number, and you get a positive number as a result, the overflow flag will be set.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">The overflow flag also gets set when you add two positive numbers and you get a negative number as a result.</span></p><p class="c13"><span class="c44 c0 c19"></span></p><a id="t.6f8b9ade48137c909c2760f422cb328a1652965e"></a><a id="t.33"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Random negative number</span></p><p class="c5"><span class="c3 c0">CLC</span></p><p class="c5"><span class="c3 c0">ADC #$70&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;$30 + $70 = $A0. Converting these numbers to decimal&hellip;</span></p><p class="c5"><span class="c10 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;48 &nbsp;+ 112 = -95? Impossible</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class="c13"><span class="c0"></span></p><p class="c13"><span class="c0"></span></p><a id="t.16ab25818aaa3bff77a4cce4509eba870cda180b"></a><a id="t.34"></a><table class="c16"><tbody><tr class="c6"><td class="c41" colspan="1" rowspan="1"><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 161.00px; height: 17.00px;"><img alt="" src="images/image00.png" style="width: 161.00px; height: 17.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c6"><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c45 c0">16-bit mode math exists. All the previous explanations apply to 16-bit math as well.</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><h4 class="c43 c22" id="h.shr1gz8ovxq5"><span class="c18 c11">Chapter 14: Bit Shifting</span></h4><p class=""><span class="c0">What if you want to divide a value at a RAM address by 2? Or multiply it by 2? There are opcodes for that!</span></p><p class="c13"><span class="c0"></span></p><p class="c9"><span class="c11 c19">ASL - </span><span class="c0">Accumulator or memory Shifts Left</span></p><p class="c9"><span class="c11 c19">LSR - </span><span class="c0">Accumulator or memory Shifts Right</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">You need to use</span><span class="c0">&nbsp;ASL</span><span class="c0">&nbsp;to multiply, and </span><span class="c0">LSR </span><span class="c0">to divide. They are officially called bit shifting though. Here is an example of multiplying:</span></p><p class="c13"><span class="c10 c0"></span></p><a id="t.167031142ab407783c058e20dd43201e047cc3d9"></a><a id="t.35"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">ASL $02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Multiply the contents of $7E0002 without affecting A.</span></p><p class="c5"><span class="c3 c0">RTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Return</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">This code multiplies the contents of $7E0002 by 2. What if you want to multiply it by 4? You need to use ASL $02 </span><span class="c0">two</span><span class="c0">&nbsp;times then. If you use ASL multiple times, you will multiply by 2, 4, 8, 16, 32, etc. LSR has this pattern too.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">To divide by 2, you need to use LSR. Here is an example:</span></p><p class="c13"><span class="c10 c0"></span></p><a id="t.cded7d91ffb8b765c4981296e673f5ec5bc8b2d7"></a><a id="t.36"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LSR $02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Divide the contents of $7E0002 by 2 without affecting A.</span></p><p class="c5"><span class="c3 c0">RTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Return</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">This code will divide the contents of $7E0002 by 2. So if </span><span class="c0">$7E0002&rsquo;s content</span><span class="c0">&nbsp;was 04, it would become 02. You can also divide it by 4 or higher by using the method like ASL - stacking the opcodes.</span></p><p class="c13"><span class="c0"></span></p><p class="c5"><span class="c0">Actually, these are different </span><span class="c0">explanations </span><span class="c0">I came up with for beginners. For people who want to go a step further:</span><span class="c0">&nbsp;</span><span class="c0">The </span><span class="c11">bits</span><span class="c0">&nbsp;in A or memory will get </span><span class="c11">shifted </span><span class="c0">when you use ASL/LSR. Let&rsquo;s take for example, this code:</span></p><p class="c13"><span class="c10 c0"></span></p><a id="t.b59745695caf3c2425a7139b77374de2dfca0e33"></a><a id="t.37"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Load 02 in A</span></p><p class="c5"><span class="c3 c0">ASL A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Multiply A by 2</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">$02 = 00000010 in Binary</span></p><p class="c5"><span class="c0">When you use AS</span><span class="c11">L</span><span class="c0">, all the bits will shift to the </span><span class="c11">l</span><span class="c0">eft 1 time. So the result will be like:</span></p><p class="c13"><span class="c10 c0"></span></p><a id="t.1961512201cf6d3bb4441801983206d1297b97d3"></a><a id="t.38"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">;A = 00000010 = $02</span></p><p class="c5"><span class="c3 c0">ASL A</span></p><p class="c5"><span class="c10 c0">;A = 00000100 = $04</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">This makes all the bits shift to the left, resulting in a normal multiplication, resulting in</span></p><p class=""><span class="c0">A = $04</span></p><p class="c13"><span class="c0"></span></p><p class="c13"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">LS</span><span class="c11">R</span><span class="c0">&nbsp;works exact the opposite; it shifts all the bits to the </span><span class="c11">r</span><span class="c0">ight:</span></p><p class="c13"><span class="c10 c0"></span></p><a id="t.dd718665e65db66231eada83550d177871aa8c87"></a><a id="t.39"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">;A = 00000010 = $02</span></p><p class="c5"><span class="c3 c0">LSR A</span></p><p class="c5"><span class="c3 c0">;A = 00000001 = $01</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class="c5"><span class="c0">This makes all the bits shift to the right, resulting in a normal division, resulting in A = $01</span></p><p class="c5 c13"><span class="c0"></span></p><p class=""><span class="c0">The carry flag has an important role during the bit shifting process. When bit 7 is set, and you do a LSR, bit 7 will be cleared, and bit 0 will move into the carry flag, either setting the flag or clearing it. It depends on the value of the bit shifted into carry. If the bit is 0, the carry flag clears. If the bit is 1, the carry flag gets set. If you do an LSR again, the carry flag will be set or clear again, depending on the result</span><span class="c0">. </span><span class="c0">Examine the examples closely, and it will begin to make sense. Examples:</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Usage of ASL and Carry Flag:</span></p><p class="c13"><span class="c10 c0"></span></p><a id="t.1ddf56db90009e837727027324d760cde0187fe1"></a><a id="t.40"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0100 0000. C = 1 &rarr; Assume that C was set at this time</span></p><p class="c5"><span class="c3 c0">ASL A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 1000 0000. C = 0 &rarr; The 0 moved into the carry flag</span></p><p class="c5"><span class="c3 c0">ASL A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0000 0000. C = 1 &rarr; The 1 moved into the carry flag</span></p><p class="c5"><span class="c3 c0">ASL A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0000 0000. C = 0 &rarr; The 0 moved into the carry flag</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Usage of LSR and Carry Flag:</span></p><p class="c13"><span class="c10 c11"></span></p><a id="t.010d4600b5fa0102d4301bd0a929a79d032b3d91"></a><a id="t.41"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$09&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0000 1001. C = 0</span></p><p class="c5"><span class="c3 c0">LSR A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0000 0100. C = 1</span></p><p class="c5"><span class="c3 c0">LSR A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0000 0010. C = 0</span></p><p class="c5"><span class="c3 c0">LSR A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0000 0001. C = 0</span></p><p class="c5"><span class="c3 c0">LSR A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0000 0000. C = 1</span></p><p class="c5"><span class="c10 c0">LSR A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0000 0000. C = 0</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">There are 2 instructions, which are ALMOST the same as LS</span><span class="c11">R</span><span class="c0">&nbsp;and AS</span><span class="c0 c29">L</span><span class="c0">:</span></p><p class="c13"><span class="c0"></span></p><p class="c9"><span class="c11 c19">ROR - </span><span class="c0">ROtate acccumulator or memory Right</span></p><p class="c9"><span class="c11 c19">ROL - </span><span class="c0">ROtate acccumulator or memory Light</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">They </span><span class="c0">behave the same as </span><span class="c0">LSR and ASL, except they are using the carry flag as </span><span class="c0">an extra </span><span class="c0">bit. Examine the following examples closely too, and you will understand what I mean</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Usage of ROL and Carry Flag:</span></p><p class="c13"><span class="c44 c0 c19"></span></p><a id="t.aca2d74047a5b4c462335ab2c311409319c869e7"></a><a id="t.42"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c10 c0">LDA #$40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0</span><span class="c44 c0 c48 c19">1</span><span class="c10 c0">00 0000. C = </span><span class="c89 c58 c55 c44 c0 c19">1</span></p><p class="c5"><span class="c10 c0">ROL A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = </span><span class="c44 c0 c48 c19">1</span><span class="c10 c0">000 000</span><span class="c44 c0 c19 c55">1</span><span class="c10 c0">. C = 0</span></p><p class="c5"><span class="c10 c0">ROL A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0000 00</span><span class="c55 c44 c0 c19">1</span><span class="c10 c0">0. C = </span><span class="c89 c58 c44 c0 c48 c19">1</span></p><p class="c5"><span class="c10 c0">ROL A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0000 0</span><span class="c55 c44 c0 c19">1</span><span class="c10 c0">0</span><span class="c44 c0 c48 c19">1</span><span class="c10 c0">. C = 0</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Usage of ROR and Carry Flag:</span></p><p class="c13"><span class="c44 c11 c19"></span></p><a id="t.a22491b7768223ec67d637c7690fa6f96f9f2fc3"></a><a id="t.43"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c10 c0">LDA #$09&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0000 </span><span class="c44 c0 c48 c19">1</span><span class="c10 c0">00</span><span class="c55 c44 c0 c19">1</span><span class="c10 c0">. C = 0</span></p><p class="c5"><span class="c10 c0">ROR A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0000 0</span><span class="c44 c0 c48 c19">1</span><span class="c10 c0">00. C = </span><span class="c89 c58 c55 c44 c0 c19">1</span></p><p class="c5"><span class="c10 c0">ROR A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = </span><span class="c55 c44 c0 c19">1</span><span class="c10 c0">000 00</span><span class="c44 c0 c48 c19">1</span><span class="c10 c0">0. C = 0</span></p><p class="c5"><span class="c10 c0">ROR A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0</span><span class="c55 c44 c0 c19">1</span><span class="c10 c0">00 000</span><span class="c44 c0 c48 c19">1</span><span class="c10 c0">. C = 0</span></p><p class="c5"><span class="c10 c0">ROR A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 00</span><span class="c55 c44 c0 c19">1</span><span class="c10 c0">0 0000. C = </span><span class="c89 c58 c44 c0 c48 c19">1</span></p><p class="c5"><span class="c10 c0">ROR A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = </span><span class="c44 c0 c48 c19">1</span><span class="c10 c0">00</span><span class="c55 c44 c0 c19">1</span><span class="c10 c0">&nbsp;0000. C = 0</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">As you can see, the carry flag IS actually involved with this bit shifting operation. The bits keep wrapping around in circles, unlike ASL/LSR! Hence they are called </span><span class="c0">&ldquo;rotate&rdquo;.</span></p><hr style="page-break-before:always;display:none;"><h4 class="c43 c22" id="h.i3j0vsbhg7k7"><span class="c18 c11">Chapter 15: Bitwise Operations</span></h4><p class=""><span class="c0">This is one of the difficult parts in ASM hacking. Yet, b</span><span class="c0">itwise operations are extremely useful. You could, for example, discard bits 7-4 in a byte. </span><span class="c0">There are many bitwise operations</span><span class="c0">&nbsp;which are also used in programming in general, not just ASM.</span><span class="c0">&nbsp;I will go through the opcodes one by one</span><span class="c0">, then give some practical examples of why these opcodes could be useful.</span></p><p class="c13"><span class="c0"></span></p><p class="c9"><span class="c11 c19">AND - </span><span class="c0">Logical AND</span></p><p class="c13"><span class="c11"></span></p><p class="c5"><span class="c12 c0">AND logically compares A with the value after the opcode, and stores the result into A. Example:</span></p><p class="c5"><span class="c12 c0">&nbsp;</span></p><a id="t.00d53bcd473dcd3d43454b2698c8fb80c57ee1ef"></a><a id="t.44"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$F0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 1111 0000</span></p><p class="c5"><span class="c3 c0">AND #$98&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;AND 1001 1000</span></p><p class="c5"><span class="c10 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 1001 0000 = $90</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">So after this operation, A will become $90, since AND stores the result back in A. AND is sometimes used to </span><span class="c1">isolate </span><span class="c12 c0">specified bits for future use. AND compares the specified bits. If there are two bits which are set, the resulting bit will be a 1. Compare the first 2 bytes downwards in the above example, then look at the result.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">If one of the bits has 0, the resulting bit will be 0. Look at this </span><span class="c0">&ldquo;</span><span class="c32 c0 c36">truth table</span><span class="c32 c0">&rdquo;</span><span class="c12 c0">:</span></p><a id="t.1ddd04984d3832c875e6ff1041bc8b455162a550"></a><a id="t.45"></a><table class="c16"><tbody><tr class="c6"><td class="c64" colspan="1" rowspan="1"><p class="c8"><span class="c1">Compared bit</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">AND operation</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">Result</span></p></td></tr><tr class="c6"><td class="c64" colspan="1" rowspan="1"><p class="c8"><span class="c1">1</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">AND 1</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">1</span></p></td></tr><tr class="c6"><td class="c64" colspan="1" rowspan="1"><p class="c8"><span class="c1">0</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">AND 1</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">0</span></p></td></tr><tr class="c6"><td class="c64" colspan="1" rowspan="1"><p class="c8"><span class="c1">1</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">AND 0</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">0</span></p></td></tr><tr class="c6"><td class="c64" colspan="1" rowspan="1"><p class="c8"><span class="c1">0</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">AND 0</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">0</span></p></td></tr></tbody></table><p class="c13"><span class="c1"></span></p><p class="c5"><span class="c0">In short, whenever there is a 0 in A or the AND value&rsquo;s bit, the resulting bit is also 0.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5 c9"><span class="c11 c19">ORA - </span><span class="c0">Logical OR</span></p><p class="c13"><span class="c12 c0"></span></p><p class="c5"><span class="c0">ORA is basically used to set specific bits:</span></p><p class="c5 c13 c50"><span class="c10 c0"></span></p><a id="t.5497598c25907cde6451bd9af057bbb1b12b2085"></a><a id="t.46"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$F0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 1111 0000</span></p><p class="c5"><span class="c3 c0">ORA #$87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;ORA 1000 0111</span></p><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 1111 0111 = $F7</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">If one of the bits has 1, the resulting bit will be 1. After ORA, the result will be stored in A for future use. Look at this truth table:</span></p><p class="c5 c13"><span class="c12 c0"></span></p><a id="t.3fa86ed7bb7126e2a53537d3e91e8fa0cd57f9b9"></a><a id="t.47"></a><table class="c16"><tbody><tr class="c6"><td class="c64" colspan="1" rowspan="1"><p class="c8"><span class="c1">Compared bit</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">ORA Operation</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">Result</span></p></td></tr><tr class="c6"><td class="c64" colspan="1" rowspan="1"><p class="c8"><span class="c1">1</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">ORA 1</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">1</span></p></td></tr><tr class="c6"><td class="c64" colspan="1" rowspan="1"><p class="c8"><span class="c1">0</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">ORA 1</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">1</span></p></td></tr><tr class="c6"><td class="c64" colspan="1" rowspan="1"><p class="c8"><span class="c1">1</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">ORA 0</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">1</span></p></td></tr><tr class="c6"><td class="c64" colspan="1" rowspan="1"><p class="c8"><span class="c1">0</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">ORA 0</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">0</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c1"></span></p><p class="c5"><span class="c12 c0">So </span><span class="c0">basically, whenever A or the ORA value&rsquo;s bit has 1, the resulting bit is also 1.</span></p><p class="c13"><span class="c12 c0"></span></p><p class="c5 c9"><span class="c11 c19">EOR - </span><span class="c0">Exclusive OR (also known as XOR)</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">I</span><span class="c12 c0">f </span><span class="c0">two 1</span><span class="c12 c0">&nbsp;come together, the result will be false. And if </span><span class="c0">two 0</span><span class="c12 c0">&nbsp;come together, the result will be also false</span><span class="c0">. In other words, if the compared bits are different, you get 1 as a result.</span><span class="c12 c0">&nbsp;Look at this truth table:</span></p><p class="c5 c13"><span class="c12 c0"></span></p><a id="t.4c0bb855fa38d48f09b54ddf7f68c33e4a9cbfff"></a><a id="t.48"></a><table class="c16"><tbody><tr class="c6"><td class="c64" colspan="1" rowspan="1"><p class="c8"><span class="c1">Compared bit</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">EOR operation</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">Result</span></p></td></tr><tr class="c6"><td class="c64" colspan="1" rowspan="1"><p class="c8"><span class="c1">1</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">EOR 1</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">0</span></p></td></tr><tr class="c6"><td class="c64" colspan="1" rowspan="1"><p class="c8"><span class="c1">0</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">EOR 1</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">1</span></p></td></tr><tr class="c6"><td class="c64" colspan="1" rowspan="1"><p class="c8"><span class="c1">1</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">EOR 0</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">1</span></p></td></tr><tr class="c6"><td class="c64" colspan="1" rowspan="1"><p class="c8"><span class="c1">0</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">EOR 0</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c8"><span class="c1">0</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Example:</span></p><p class="c5 c50 c13"><span class="c10 c0"></span></p><a id="t.411155486e5098cfc559d299374d7107e96741b9"></a><a id="t.49"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$99&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; A = 1001 1001</span></p><p class="c5"><span class="c3 c0">EOR #$F0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; EOR 1111 0000</span></p><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; A = 0110 1001 = $69</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">After the EOR, the result will be stored back to A.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c0">There are also opcodes to set bits directly:</span></p><p class="c5 c9"><span class="c11 c19">TSB - </span><span class="c0">Test and Set Bit</span></p><p class="c5 c9"><span class="c11 c19">TRB - </span><span class="c0">Test and Reset Bit</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c12 c0">These opcodes takes the value in A, and (re)sets the specified bits of a RAM addresses using it. Here is an example:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.58d9ec07a6e530d586d1bc87a365c79a1966b300"></a><a id="t.50"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c10 c0">LDA #$01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0000 000</span><span class="c28 c0 c19">1</span><span class="c3 c0">. $7E0010 = 1111 0010 </span></p><p class="c5"><span class="c10 c0">TSB $10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;$7E0010 = 1111 001</span><span class="c0 c19 c25">1</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">This is the same as:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.7466ce46c63e44f3d97e60330469ba356799e16b"></a><a id="t.51"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A becomes 1111 0010</span></p><p class="c5"><span class="c10 c0">ORA #$01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;OR with 0000 000</span><span class="c28 c0 c19">1</span><span class="c10 c0">. A becomes 1111 001</span><span class="c25 c0 c19">1</span></p><p class="c5"><span class="c3 c0">STA $10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Store back into RAM $7E0010</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">As you can see, the first one saves more time and lines.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c12 c0">TRB works exactly the opposite:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.c75dd4a17de04e46314914b0130bb2e6795cfd08"></a><a id="t.52"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c10 c0">LDA #$01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 0000 000</span><span class="c28 c0 c19">1</span><span class="c3 c0">. $7E0010 = 1111 1111</span></p><p class="c5"><span class="c10 c0">TRB $10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;$10 = 1111 111</span><span class="c25 c0 c19">0</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5 c13"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c12 c0">This is the same as:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.7d331b1f6ca1984e11d034182b7d230a4f8056c8"></a><a id="t.53"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 1111 1111</span></p><p class="c5"><span class="c3 c0">AND #$FE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Set bit 0 to 0.</span></p><p class="c5"><span class="c3 c0">STA $10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Store back into $7E0010. $10 = 1111 1110</span></p></td></tr></tbody></table><p class="c5"><span class="c0">As you can see, thanks to TRB you don&rsquo;t even have to convert a number to its inverse value (#$FE in this case) to reset a certain bit.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c12 c0">There is also an opcode which is almost the same as AND. It&rsquo;s used to do comparisons.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5 c9"><span class="c11 c19">BIT -</span><span class="c0">&nbsp;BIt Test</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">Basically i</span><span class="c12 c0">t is a logical AND. It does affect the processor flags</span><span class="c0">,</span><span class="c12 c0">&nbsp;</span><span class="c0">e</span><span class="c12 c0">xcept the result is NOT stored into A. See Processor Flags chapter for explanation about the processor flags. Here is an example:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.0122a0963c25166f7a5aec58c67c555cbe3ec524"></a><a id="t.54"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Let&rsquo;s just randomly load a value into A. A = 0000 0100 = $04</span></p><p class="c5"><span class="c3 c0">BIT #$00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;We supposedly clear A by doing a logical AND with value $00</span></p><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;The zero flag has been set. But the result? A is still $04.</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">More in-depth explanation about BIT can be found later in this tutorial.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">So what can bitwise operations be used for? There are many uses of bitwise operations in SNES games. The most common usages I have seen so far is:</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">EOR:</span></p><ul class="c53 lst-kix_jxdv6vpg8s4z-0 start"><li class="c5 c31"><span class="c0">For example, flipping a sprite&rsquo;s direction bit. Doing EOR #$01 to a sprite&rsquo;s direction address would cause it to switch directions, because the current direction flag has been changed from its current value to the opposite, i.e. 0 to 1, or 1 to 0.</span></li><li class="c5 c31"><span class="c0">Getting a negative speed value. If one wants the negative value of a speed, one can do EOR #$FF to flip all the bits, causing the speed value to be inversed.</span></li></ul><p class="c5"><span class="c0">ORA:</span></p><ul class="c53 lst-kix_ltt0rgoz0br6-0 start"><li class="c5 c31"><span class="c0">Compare a series of addresses to see if they&rsquo;re set or not. Suppose the following code:</span></li></ul><p class="c13"><span class="c10 c0"></span></p><a id="t.e52c23fe5588443a390f3f1db57f92f17efa07c3"></a><a id="t.55"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $00</span></p><p class="c5"><span class="c3 c0">ORA $01</span></p><p class="c5"><span class="c3 c0">ORA $02</span></p><p class="c5"><span class="c3 c0">ORA $03</span></p><p class="c5"><span class="c3 c0">BEQ AllClear</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">This code basically loads the value of address $00 into A, then ORs it with RAM $01, its result being stored in A. Then the same happens with $02, and so on. If the result is $00, the branch is taken. This means that if every address has the value $00, the branch is taken. It&rsquo;s better than doing LDA $00, BEQ Clear, LDA $01, BEQ Clear, and so on. You compare all the addresses in one fell swoop.</span></p><hr style="page-break-before:always;display:none;"><p class="c13"><span class="c0"></span></p><ul class="c53 lst-kix_qwoq0ceavo4-0 start"><li class="c31"><span class="c0">Set a certain bit of an address. For example, you have a RAM address which keeps track of the player status. It contains both the player&rsquo;s direction and its powerup status, big or small. If you want to only change the powerup status, you use ORA (or even better, TSB) to set its powerup status only. If you used LDA and STA, you would also inadvertently overwrite the direction status of the player.</span></li></ul><p class="c5"><span class="c0">AND:</span></p><ul class="c53 lst-kix_jjby49jfkxyx-0 start"><li class="c5 c31"><span class="c0">AND can be used to mask out certain bits. Let&rsquo;s take the player powerup status + direction example again. You can use AND with a certain bit and check if the result is 1. If it&rsquo;s 1, that bit is set. Example:</span></li></ul><p class="c13"><span class="c10 c0"></span></p><a id="t.1885aa6ce9a88c02c92e754f8076877e7d6b00fa"></a><a id="t.56"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $0102</span></p><p class="c5"><span class="c3 c0">AND #$02</span></p><p class="c5"><span class="c3 c0">BNE IsPoweredUp</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">In this case, if bit 1 is set, the branch is taken. This really only checks for the bit. The value of the address can be anything, from #$FF to #$23, only bit 1 matters in this scenario. As long as that one specific bit is set, branch.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">BIT:</span></p><ul class="c53 lst-kix_bptz5kijd0at-0 start"><li class="c31"><span class="c0">The SNES controller input is bitwise. All button presses are stored as bits rather than bytes. Using BIT, you can test if a certain button is pressed (but without affecting the accumulator). You might be asking though, why BIT rather than AND? For that, please see the &ldquo;in-depth look at some opcodes&rdquo; chapter. BIT has a feature which distinguishes it from a regular AND, involving processor flags.</span></li></ul><hr style="page-break-before:always;display:none;"><h4 class="c43 c22" id="h.rkoelvi8slkj"><span class="c0 c18">Chapter 16: Affecting Processor Flags </span><span class="c0 c29 c18">manually</span></h4><p class="c5"><span class="c0">The SNES has the opcodes </span><span class="c32 c0">REP</span><span class="c0">&nbsp;and </span><span class="c32 c0">SEP</span><span class="c0">. </span><span class="c12 c0">What are they, and what do they do, actually? They affect the </span><span class="c36 c32 c0">processor flags</span><span class="c12 c0">, which affects the behaviour of the SNES. There are 8 processor flags stored in the Processor Flag Register as a single byte:</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 593.07px; height: 196.00px;"><img alt="" src="images/image03.png" style="width: 593.07px; height: 196.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c12 c0">(For in-depth explanations of the flags please refer to chapter 18)</span></p><p class="c8 c13"><span class="c0"></span></p><p class="c5 c9"><span class="c11 c19">REP -</span><span class="c0">&nbsp;REset Processor status</span></p><p class="c5"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">SEP -</span><span class="c0">&nbsp;Set Processor status</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c12 c0">SEP sets the selected bits to 1 while</span><span class="c0">&nbsp;</span><span class="c12 c0">REP resets the selected bits to 0</span><span class="c0">. They work pretty much like TSB and TRB from the previous chapter, except these opcodes affect the SNES processor flags.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">In the image, m and x are described as Index Register/Memory/Accumulator select. The index register is in fact the x and y 8- or 16-bit mode register, while the memory/accumulator select is the same, just for the accumulator.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c12 c0">SEP works as following:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.051b6cdf0e49e45f54e6ee74361fcd3e1fb22dc7"></a><a id="t.57"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">;P= nvmxdizc = $00</span></p><p class="c5"><span class="c3 c0">; = 00000000</span></p><p class="c5"><span class="c10 c0">SEP #$80</span><span class="c44 c0 c19">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c3 c0">;= 1000 0000</span></p><p class="c5"><span class="c3 c0">;P= Nvmxdizc</span></p><p class="c5"><span class="c3 c0">; = 10000000 = $80</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">The uppercased letters are the activated processor flags. This code sets the negative flag.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">REP works as following:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.d80979cde3aa36a3fc69d2433c91c779b3bb8a39"></a><a id="t.58"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">P= NvmxDizc = $88</span></p><p class="c5"><span class="c3 c0">&nbsp;= 10001000</span></p><p class="c5"><span class="c3 c0">REP #$08&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;= 0000 1000</span></p><p class="c5"><span class="c3 c0">P= Nvmxdizc</span></p><p class="c5"><span class="c3 c0">&nbsp;= 10000000 = $80</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">In the beginning, the decimal mode was enabled, and the negative flag was set, but after REP #$08, the decimal mode flag got disabled, but the negative flag still is set.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c12 c0">What is </span><span class="c1">e</span><span class="c12 c0">&nbsp;doing up there in the image, you ask?</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c12 c0">It is the &lsquo;hidden&rsquo; Emulation Mode. When it is set, SNES basically acts like 6502 (NES CPU), which is far more limited.</span><span class="c1">&nbsp;</span><span class="c12 c0">While in emulation mode, the accumulator, X and Y register are forced to be 8-bit and one of the processor flag is used to indicate </span><span class="c0">BRK</span><span class="c12 c0">. It also uses different vectors for interrupt</span><span class="c1">. </span><span class="c12 c0">&nbsp;You can&rsquo;t set the emulation mode using REP and SEP. Emulation mode is basically an &lsquo;improved&rsquo; 6502 processor emulation.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c12 c0">You can access the Emulation Mode by using SEC XCE, and leave it using CLC XCE. By default, SNES starts up in emulation mode.</span><hr style="page-break-before:always;display:none;"></p><h4 class="c22" id="h.aazbl4mjcn64"><span class="c0 c18">Chapter 17: Moving chunks of data</span></h4><p class="c5"><span class="c12 c0">There are 2 opcodes to transfer a whole bunch of data to a</span><span class="c0">n a</span><span class="c12 c0">ddress:</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">MVP - </span><span class="c0">MoVe block Positive</span></p><p class="c5 c9"><span class="c11 c19">MVN - </span><span class="c0">MoVe block Negative</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">MVN is the easiest to use. MVP and MVN </span><span class="c0">practically</span><span class="c12 c0">&nbsp;do a mass amount of LDA and STA to some RAM addresses. You can</span><span class="c0">&rsquo;t move data to ROM, because, well, ROM is read-only.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c0">To use MVN, </span><span class="c12 c0">make sure AXY = 16-bit and use PHB and PLB, so the code looks like this:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.a11c7af5ff60a92780f2c5c5ce121f75b1f13922"></a><a id="t.59"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">PHB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Preserve data bank<br>REP #$30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;16-bit AXY<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&larr; Move instructions are located here</span></p><p class="c5"><span class="c3 c0">SEP #$30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;8-bit AXY<br>PLB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Recover data bank</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c36 c32 c0"></span></p><p class="c5"><span class="c12 c0">A is used for the amount of bytes to transfer.<br>X is used for the high and the low bytes of the source.<br>Y is used for the high and the low bytes of the destination address.</span></p><p class="c5"><span class="c12 c0"><br>You must input MVN for xkas as this: MVN $</span><span class="c1">xx</span><span class="c12 c0">xx, which the first byte (boldened) is the source bank, and the second byte for the destination bank.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c12 c0">MVN transfers the amount of bytes specified in A. The start address of source is in X, start address of destination in Y. X and Y increase for each byte that is being transferred, A decreases. When A hits $FFFF, the transfer is done</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Let&rsquo;s take this as an example:</span><span class="c1"><br><br>A = $000F </span><span class="c12 c0">; (nummer 15, but it</span><span class="c0">&rsquo;s 16 bytes because the size is defined as A+1)</span><span class="c1"><br>X = $8908<br>Y = $A000<br><br></span><span class="c12 c0">Using </span><span class="c0">&ldquo;</span><span class="c12 c0">MVN $1F7F</span><span class="c0">&rdquo;</span><span class="c12 c0">, this will transfer 16 bytes, from ROM $1F8908, to RAM $7FA000. </span></p><p class="c5"><span class="c12 c0">Useful when you want to load a HDMA table in RAM without a massive amount of LDAs and STAs, including indexing with additional loops. MVP is more complicated. Explanation is in the next page.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">Oh yeah, of course you simply set A, X and Y using LDA #$000F, LDX #$8908, etc. in 16-bit AXY mode.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c5"><span class="c12 c0">You must input MVP for xkas as this: MVP $</span><span class="c1">xx</span><span class="c12 c0">xx, wh</span><span class="c0">ere</span><span class="c12 c0">&nbsp;the first byte (boldened) is the source bank, and the second byte </span><span class="c0">is</span><span class="c12 c0">&nbsp;the destination bank. The X register serves as the </span><span class="c1">end</span><span class="c12 c0">&nbsp;of the source table, as opposed to MVN. The Y register serves as the </span><span class="c1">end</span><span class="c12 c0">&nbsp;of the destination, as opposed to MVN.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Let&rsquo;s take this as an example:</span><span class="c1"><br><br>A = $000F<br>X = $8908<br>Y = $A000<br><br></span><span class="c12 c0">Using </span><span class="c0">&ldquo;</span><span class="c12 c0">MVP $1F7F</span><span class="c0">&rdquo;</span><span class="c12 c0">, this will transfer 16 bytes, from ROM $1F8908 minus the value in A, to RAM $7FA000 minus the value in A. This one is much more complicated, and you might want to avoid using it</span><span class="c0">. Just a personal recommendation.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">While MVP is transferring data, X and Y decrease (as opposed to MVN where they increase). This is why you have to specify the source/destination&rsquo;s end address instead of the begin address.</span></p><hr style="page-break-before:always;display:none;"><h4 class="c22" id="h.jsiajsqzqisf"><span class="c18 c11">Chapter 18: Indexing with X and </span><span class="c18 c11">Y</span></h4><p class="c5"><span class="c0">Indexing is the act of accessing a table of data from a certain offset, that offset being determined by an </span><span class="c32 c0">indexer</span><span class="c0">. </span><span class="c12 c0">X and Y are important in indexing. In fact, they can&rsquo;t be missed, because their main purpose is indexing after a</span><span class="c0">ll</span><span class="c12 c0">. I&rsquo;ll show you a </span><span class="c0">piece of</span><span class="c12 c0">&nbsp;code and explain it afterwards:</span></p><p class="c5 c13"><span class="c11"></span></p><a id="t.83fa24aa3c03d779036ed4a1ef1400a99ef8c379"></a><a id="t.60"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDY $12 &nbsp; &nbsp; &nbsp; &nbsp;;Y is now loaded with the number $03</span></p><p class="c5"><span class="c3 c0">LDA Table,y &nbsp; &nbsp;;Load a number from the table into A using y as index</span></p><p class="c5"><span class="c3 c0">STA $01</span></p><p class="c5"><span class="c3 c0">RTS</span></p><p class="c5 c13"><span class="c3 c0"></span></p><p class="c5"><span class="c3 c0">;Index # &nbsp;$00 $01 $02 $03 $04</span></p><p class="c5"><span class="c10 c0">Table: db $03,$86,$91,$38,$22</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c1"></span></p><p class="c5"><span class="c12 c0">This is where </span><span class="c36 c32 c0">tables</span><span class="c12 c0">&nbsp;start to play an important role, and here&rsquo;s a quick crash course on them.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Tables are a sequence of bytes. They are </span><span class="c1">pure values </span><span class="c12 c0">mostly used in conditional cases. They can also contain various data such as positions of objects, level data, speed data, </span><span class="c1">anything!</span><span class="c12 c0">&nbsp;In this case, the bytes are a &ldquo;byte&rdquo;, not &ldquo;word&rdquo; or &ldquo;long&rdquo;, hence &ldquo;db&rdquo;: direct byte. The table in this example serves no other purpose than demonstrating indexing. </span><span class="c0">I</span><span class="c12 c0">n this case, the table is located </span><span class="c0">somewhere inside the ROM. Tables are preceded by a label so that you can refer to it easily within your code.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c12 c0">Now, when you assume that $7E0012 holds the value $03, Y will be loaded with $03 (Because we used LDY). </span><span class="c0">What happens next?</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">The code will load a value from the table into A. Let&rsquo;s assume that this table is located at ROM $1F:B000. Basically, this does LDA $1FB000 PLUS the value in Y, so this code actually does LDA $B003 in the end (implicitly). The $1FB003 here is the </span><span class="c1">offset</span><span class="c12 c0">&nbsp;of the data loaded. $1F:B003&rsquo;s value is $38 in the table in this case, so this actually loads $38 in A.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Indexing is quite useful when you don&rsquo;t want to write very repetitive instructions all the time. Indexing can be performed with X too, of course. X and Y behave exactly the same, after all.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">Tables have very practical applications in SNES games. You can, for example, store text data in tables. Or level data. Or palette data. You can program the game to grab the values from the table using a loop, rather than doing repeated LDAs and STAs.</span></p><hr style="page-break-before:always;display:none;"><h4 class="c43 c22" id="h.aa9xafku5faw"><span class="c18 c11">Chapter 19: Transfer</span></h4><p class="c5"><span class="c12 c0">There are lots of transfer opcodes, and their process is extremely simple (most of them anyway):</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">What they do is</span><span class="c1">&nbsp;copy</span><span class="c12 c0">&nbsp;a value from a register to another register. See this example:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.c286581f2e05c74a7b1540b84962a8963d427c86"></a><a id="t.61"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">;A = $45</span></p><p class="c5"><span class="c3 c0">;Y = $99</span></p><p class="c5"><span class="c3 c0">TAY</span></p><p class="c5"><span class="c3 c0">;A = $45</span></p><p class="c5"><span class="c3 c0">;Y = $45</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">This will </span><span class="c36 c32 c0">copy</span><span class="c12 c0">&nbsp;the contents of the A register, into the Y register.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">T</span><span class="c12 c0">here are these couple of opcodes which do the same copy progress. I will not name them because I</span><span class="c0">&nbsp;believe the opcodes themselves are self-explanatory</span><span class="c12 c0">:</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c11 c19 c51">TA</span><span class="c11 c19">X -</span><span class="c0">&nbsp;</span><span class="c12 c0">This copies the contents of A into X. </span><span class="c0">This opcode does </span><span class="c11">not</span><span class="c0">&nbsp;call the tax collector. </span></p><p class="c5"><span class="c11 c19">TAY -</span><span class="c12 c0">&nbsp;This opcode copies the contents of A into Y</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c11 c19">TXA -</span><span class="c12 c0">&nbsp;This opcode copies the contents of X into A</span></p><p class="c5"><span class="c11 c19">TXY -</span><span class="c12 c0">&nbsp;This opcode copies the contents of X into Y</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c11 c19">TYA -</span><span class="c0">&nbsp;T</span><span class="c12 c0">his opcode copies the contents of Y into A</span></p><p class="c5"><span class="c11 c19">TYX -</span><span class="c12 c0">&nbsp;This opcode copies the contents of Y into X </span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Here are some special transfer instructions, which affect the other general registers:</span></p><p class="c5 c13"><span class="c11 c19"></span></p><p class="c5"><span class="c11 c19">TCD -</span><span class="c0">&nbsp;</span><span class="c12 c0">Transfer the 16-bit value in A, to the direct page register, regardless of A being in the 16-bit mode or not.</span></p><p class="c5"><span class="c11 c19">TDC -</span><span class="c0">&nbsp;</span><span class="c12 c0">Transfer the 16-bit value in the direct page register to the A register, regardless of A being in the 16-bit mode or not.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c11 c19">TCS -</span><span class="c0">&nbsp;</span><span class="c12 c0">Transfers the 16-bit value in A to the stack pointer.</span></p><p class="c5"><span class="c11 c19">TSC -</span><span class="c0">&nbsp;</span><span class="c12 c0">Transfers the 16-bit stack pointer to the A register.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c11 c19">TXS -</span><span class="c0">&nbsp;</span><span class="c12 c0">Transfers the 16-bit value in X to the stack pointer.</span></p><p class="c5"><span class="c11 c19">TSX -</span><span class="c0">&nbsp;</span><span class="c12 c0">Transfers the 16-bit stack pointer to the X register.</span></p><hr style="page-break-before:always;display:none;"><p class="c5"><span class="c12 c0">TAX, TAY, TXA, TXY, TYA, TYX also work when A, or XY are in 16-bit mode:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.80aa367d561045475ecf273982c6c15f12bb096d"></a><a id="t.62"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">REP #$30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A, X, Y are all 16-bit mode.</span></p><p class="c5"><span class="c3 c0">LDA #$1337&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A has now the number $1337</span></p><p class="c5"><span class="c3 c0">TAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Copy A to X. X has now the number $1337</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">If X wasn&rsquo;t 16-bit mode, it would only copy over the $37 part over to X, and the high byte of X would stay cleared. </span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Earlier in this tutorial I&rsquo;ve mentioned that A is in reality always 16-bits long. So if you load something into A in 8-bit mode, the high byte always stays the same. Take the following example:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.c777bbd460ea65e4efbdd5309f7abdaf1c60519f"></a><a id="t.63"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = $1337, but is in 8-bit mode. If you tried to</span></p><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;read A, it would return the number $37</span></p><p class="c5"><span class="c3 c0">REP #$10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = 8-bit. XY = 16-bit</span></p><p class="c5"><span class="c3 c0">LDA #$10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = $1310</span></p><p class="c5"><span class="c3 c0">LDX #$FFFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;X = $FFFF</span></p><p class="c5"><span class="c10 c0">TXA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = $13FF</span><span class="c10 c11">&nbsp;</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c1"></span></p><p class="c5"><span class="c12 c0">As you can see, the high byte of A never gets touched simply because A is 8-bit.</span></p><hr style="page-break-before:always;display:none;"><h4 class="c43 c22" id="h.x6wso9plphn"><span class="c18 c11">Chapter 20: Miscellaneous Opcodes</span></h4><p class="c5"><span class="c12 c0">In this chapter I will describe misc. opcodes which don&rsquo;t really require complex explanations.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5 c9"><span class="c11 c19">NOP </span><span class="c11 c19">-</span><span class="c0">&nbsp;</span><span class="c12 c0">No O</span><span class="c0">P</span><span class="c12 c0">eration</span></p><p class="c5"><span class="c12 c0">This opcode will do absolutely NOTHING. It is often used to disable existing opcodes in a ROM, or used to give time for the math hardware registers to do their work. </span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5 c9"><span class="c11 c19">SEI</span><span class="c11 c19">&nbsp;-</span><span class="c0">&nbsp;SEt Interrupt disable flag</span></p><p class="c5"><span class="c12 c0">This sets the interrupt </span><span class="c36 c32 c0">disable </span><span class="c12 c0">flag in the processor flags. In other words, this </span><span class="c0">disables interrupts</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5 c9"><span class="c11 c19">SEC -</span><span class="c0">&nbsp;</span><span class="c12 c0">S</span><span class="c0">E</span><span class="c0 c12">t Carry </span><span class="c0">f</span><span class="c12 c0">lag:</span></p><p class="c5"><span class="c12 c0">It basically writes 1 to the Carry Flag.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5 c9"><span class="c11 c19">SED</span><span class="c11 c19">&nbsp;-</span><span class="c0">&nbsp;</span><span class="c12 c0">S</span><span class="c0">E</span><span class="c12 c0">t Decimal </span><span class="c0">f</span><span class="c12 c0">lag:</span></p><p class="c5"><span class="c12 c0">Sets the decimal flag by writing 1 to the decimal flag</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5 c9"><span class="c11 c19">CLC </span><span class="c11 c19">-</span><span class="c0">&nbsp;</span><span class="c12 c0">C</span><span class="c0">L</span><span class="c12 c0">ear Carry </span><span class="c0">f</span><span class="c12 c0">lag:</span></p><p class="c5"><span class="c12 c0">It basically writes 0 to the Carry Flag.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5 c9"><span class="c11 c19">CLD</span><span class="c11 c19">&nbsp;-</span><span class="c0">&nbsp;</span><span class="c12 c0">C</span><span class="c0">L</span><span class="c12 c0">ear Decimal </span><span class="c0">f</span><span class="c12 c0">lag</span></p><p class="c5"><span class="c12 c0">Clears the decimal flag by writing 0 to the decimal flag.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5 c9"><span class="c11 c19">CLI</span><span class="c11 c19">&nbsp;-</span><span class="c0">&nbsp;CLear Interrupt disable flag</span></p><p class="c5"><span class="c12 c0">This clears the interrupt </span><span class="c36 c32 c0">disable</span><span class="c12 c0">&nbsp;flag in the processor flags. </span><span class="c0">In other words, this enables interrupts.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5 c9"><span class="c11 c19">CLV </span><span class="c11 c19">-</span><span class="c0">&nbsp;CLear oVerflow flag</span></p><p class="c5"><span class="c12 c0">This clears the overflow flag of the processor flags</span><span class="c0">.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5 c9"><span class="c11 c19">XBA </span><span class="c11 c19">-</span><span class="c0">&nbsp;eX</span><span class="c12 c0">change B and A:</span></p><p class="c5"><span class="c12 c0">It swaps the high and the low bytes of the (16-bit) A register re</span><span class="c0">gardless of the register size</span><span class="c12 c0">. Example:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.5f733b75b6dc91cb8b6557d6e9200c8b72cca5a0"></a><a id="t.64"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">;A = $3475</span></p><p class="c5"><span class="c10 c0">XBA</span></p><p class="c5"><span class="c3 c0">;A = $7534</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5 c9"><span class="c11 c19">WAI </span><span class="c11 c19">-</span><span class="c0">&nbsp;</span><span class="c12 c0">W</span><span class="c0">AI</span><span class="c12 c0">t for interrupt:</span></p><p class="c5"><span class="c12 c0">This halts the whole </span><span class="c0">program</span><span class="c12 c0">, until an interrupt occurs, which is either NMI or IRQ.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5 c13"><span class="c12 c0"></span></p><hr style="page-break-before:always;display:none;"><h4 class="c22" id="h.qr5bqe7y71lm"><span class="c18 c11">Chapter 21: Stack; Push and Pull </span><span class="c15 c0">&nbsp;Important</span></h4><p class="c5"><span class="c0">The stack holds data you &ldquo;push&rdquo; onto it (either explicitly or implicitly). Imagine the stack as a</span><span class="c12 c0">&nbsp;stack of books in a thin, lo</span><span class="c0">ng crate</span><span class="c12 c0">, and you can only add books (push) from above and take books from above (pull/pop). Imagine the stack as something like this:</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 90.00px; height: 171.00px;"><img alt="" src="images/image05.png" style="width: 90.00px; height: 171.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">The blue boxes are books (bytes), and they can hold any value in it. When you push something on the stack&hellip;</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 239.00px; height: 226.00px;"><img alt="" src="images/image04.png" style="width: 239.00px; height: 226.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c13"><span class="c12 c0"></span></p><p class="c8"><span class="c12 c0">A value is added after the last value. And when you pull from the stack&hellip;</span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 240.00px; height: 260.00px;"><img alt="" src="images/image02.png" style="width: 240.00px; height: 260.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c5"><span class="c0">Y</span><span class="c12 c0">ou cannot push/pull stuff at the bottom, since it is &lsquo;closed&rsquo;. Basically, </span><span class="c0">&ldquo;last in, first out.&rdquo;</span></p><p class="c5 c13"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">There are opcodes to push the current value inside the A, X or Y registers onto the stack:</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5 c9"><span class="c11 c19">PHA -</span><span class="c0">&nbsp;PusH A onto stack</span></p><p class="c5 c9"><span class="c11 c19">PHX -</span><span class="c0">&nbsp;PusH X onto stack</span></p><p class="c5 c9"><span class="c11 c19">PHY -</span><span class="c0">&nbsp;PusH Y onto stack</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">There are also opcodes to pull a value from the stack into the A, X or Y registers:</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">PLA -</span><span class="c0">&nbsp;PulL into A from stack</span></p><p class="c5"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">PLX -</span><span class="c0">&nbsp;PulL into X from stack</span></p><p class="c5"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c11 c19">PLY -</span><span class="c0">&nbsp;PulL into Y from stack</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Here is an example code, think of something like</span><span class="c0">:</span><span class="c12 c0">&nbsp;X needs to stay at the value $19, but you really have to use X for something else. How would one do that?</span><span class="c0">&nbsp;Y</span><span class="c12 c0">ou use PHX to preserve </span><span class="c0">the value in X in the stack,</span><span class="c12 c0">&nbsp;before you use an instruction which modifies the contents of X:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.b8ccc886219fdd2c409e538b16a3de1cd47348c2"></a><a id="t.65"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c10 c0">PHX &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Push X ($19) onto stack. Result: Stack 1</span><span class="c10 c0 c71">st</span><span class="c3 c0">&nbsp;value = #$19</span></p><p class="c5"><span class="c3 c0">TAX &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Transfers A to X, modifying X&rsquo; contents.</span></p><p class="c5"><span class="c3 c0">LDA $8873,x ;\</span></p><p class="c5"><span class="c3 c0">STA $0100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;/Indexing instruction</span></p><p class="c5"><span class="c3 c0">PLX &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Restore X. X is now #$19 instead of remaining modified</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><a id="t.52c70f75d1600f8834fc49235a07c8e57602ecf8"></a><a id="t.66"></a><table class="c16"><tbody><tr class="c6"><td class="c41" colspan="1" rowspan="1"><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 161.00px; height: 17.00px;"><img alt="" src="images/image00.png" style="width: 161.00px; height: 17.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c6"><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c0 c57">The registers A, X and Y do </span><span class="c11 c57">not</span><span class="c45 c0">&nbsp;have a separate stack. There is only one stack, specified by the stack pointer register.</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">As you push a value to the stack, it gets pushed to the location where the </span><span class="c1">stack pointer register</span><span class="c12 c0">&nbsp;points to. After each push, the stack pointer </span><span class="c1">decreases</span><span class="c12 c0">, so the bytes are pushed backwards. They </span><span class="c1">overwrite</span><span class="c12 c0">&nbsp;the RAM address&rsquo; contents.</span><span class="c0">&nbsp;</span><span class="c12 c0">Here is an example of how the stack works</span><span class="c0">&nbsp;from the RAM&rsquo;s point of view</span><span class="c12 c0">:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.8f7324241abb096b158b1df3b060ec91ea84584a"></a><a id="t.67"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Stack: .. 55 55 55 55 55 55 ..</span></p><p class="c5"><span class="c3 c0">LDA #$69</span></p><p class="c5"><span class="c3 c0">PHA</span></p><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Stack: .. 55 55 55 55 55 69 ..</span></p><p class="c5"><span class="c3 c0">LDA #$AA</span></p><p class="c5"><span class="c3 c0">PHA</span></p><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Stack: .. 55 55 55 55 AA 69 ..</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">When you pull something from the stack, it gets pulled from the location </span><span class="c0">of </span><span class="c12 c0">the stack pointer. After each pull, the stack pointer </span><span class="c1">increases</span><span class="c12 c0">. The bytes are pulled back into a register. You do not extract the byte literally out of the RAM. You just copy the byte to the register you pull it into. The byte in the stack does not reset or anything. It remains the same.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">The stack doesn&rsquo;t have a defined size. Instead, you just reserve an area of RAM for the stack. The reason it doesn&rsquo;t have a defined size is because as long as you keep pushing, the stack pointer keeps decreasing. If you push too many values, you might accidentally overwrite RAM addresses with actual purposes.</span><hr style="page-break-before:always;display:none;"></p><p class="c13"><span class="c0"></span></p><a id="t.7e6357ecb63b921771d94cc391a7db5b56eb59da"></a><a id="t.68"></a><table class="c16"><tbody><tr class="c6"><td class="c41" colspan="1" rowspan="1"><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 161.00px; height: 17.00px;"><img alt="" src="images/image00.png" style="width: 161.00px; height: 17.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c6"><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c45 c0">16-bit stack operations are possible as well. Instead of pushing and pulling one byte, you work with two bytes instead. For example, in 16-bit A mode, PHA pushes a 16-bit number onto the stack, not an 8-bit number. Same with pull - you&rsquo;ll pull a 16-bit number from the stack into A using PLA.</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class="c5"><span class="c12 c0">There are also other push and pull commands, which are not affected by 8 or 16-bit mode:</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5 c9"><span class="c11 c19">PHB -</span><span class="c0">&nbsp;PusH Bank register onto stack</span></p><p class="c5"><span class="c12 c0">Pushes the 8-bit data bank register onto the stack.</span></p><p class="c5 c13"><span class="c11"></span></p><p class="c5 c9"><span class="c11 c19">PLB -</span><span class="c0">&nbsp;PulL Bank register from stack</span></p><p class="c5"><span class="c12 c0">Pulls the 8-bit value into the data bank register from the stack.</span></p><p class="c5 c13"><span class="c11"></span></p><p class="c5 c9"><span class="c11 c19">PHD -</span><span class="c0">&nbsp;PusH Direct page register onto stack</span></p><p class="c5"><span class="c12 c0">Pushes the 16-bit direct page register onto the stack.</span></p><p class="c5 c13"><span class="c11"></span></p><p class="c5 c9"><span class="c11 c19">PLD -</span><span class="c0">&nbsp;PulL Direct page register from stack</span></p><p class="c5"><span class="c12 c0">Pulls the 16-bit value into the direct page register.</span></p><p class="c5 c13"><span class="c11"></span></p><p class="c5 c9"><span class="c11 c19">PHP -</span><span class="c0">&nbsp;PusH Processor flags onto stack</span></p><p class="c5"><span class="c12 c0">Pushes the 8-bit current processor flags&rsquo; status onto the stack.</span></p><p class="c5 c13"><span class="c11"></span></p><p class="c5 c9"><span class="c11 c19">PLP -</span><span class="c0">&nbsp;PulL Processor flags from stack</span></p><p class="c5"><span class="c12 c0">Pulls the 8-bit value into the processor flags&rsquo; status from the stack.</span></p><p class="c5 c13"><span class="c11"></span></p><p class="c5 c9"><span class="c11 c19">PHK -</span><span class="c0">&nbsp;Push current program bank onto stack</span></p><p class="c5"><span class="c12 c0">Pushes the 8-bit current program bank onto the stack (the bank byte of the progra</span><span class="c0">m counter)</span><span class="c12 c0">. There is no pull version of this.</span></p><p class="c5 c13"><span class="c11"></span></p><p class="c5 c9"><span class="c11 c19">PEA $XXXX -</span><span class="c0">&nbsp;Push Effective Address</span></p><p class="c5"><span class="c12 c0">Pushes a specified 16-bit value onto the stack</span></p><p class="c5 c13"><span class="c11"></span></p><p class="c5 c9"><span class="c11 c19">PEI ($XX) -</span><span class="c0">&nbsp;</span><span class="c12 c0">Push Effective Indirect address</span></p><p class="c5"><span class="c12 c0">Pushes the 16-bit value at the specified RAM address onto the stack. </span></p><p class="c5 c13"><span class="c11"></span></p><p class="c5 c9"><span class="c11 c19">PER </span><span class="c32 c11 c19">label</span><span class="c11 c19">&nbsp;-</span><span class="c0">&nbsp;Push program counter relative</span></p><p class="c5"><span class="c12 c0">Pushes the 16-bit value at a specified label. The location (the parameter o</span><span class="c0">f the opcode) </span><span class="c12 c0">is relative to this instruction once the code has been assembled.</span></p><p class="c13"><span class="c0"></span></p><a id="t.0671904e9c512e6a534142370d353dce7a404475"></a><a id="t.69"></a><table class="c16"><tbody><tr class="c6"><td class="c41" colspan="1" rowspan="1"><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 161.00px; height: 17.00px;"><img alt="" src="images/image00.png" style="width: 161.00px; height: 17.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c6"><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c11 c57">All </span><span class="c45 c0">pulling instructions affect the N and the Z processor flags, which are Negative and Zero.</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><h4 class="c43 c22 c61" id="h.o8swqwhsyhhv"><span class="c0 c18"></span></h4><h4 class="c43 c22" id="h.7o9mnt86asdy"><span class="c0 c18">Chapter 22: In-depth look at some opcodes</span></h4><p class="c5"><span class="c0">By now, the basics of ASM should be clear, but so far the opcodes have been explained in basic terms. Some opcodes do a lot more behind the scenes for them to function properly.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">First of all: </span><span class="c1">BEQ</span><span class="c11">, </span><span class="c1">BNE and CMP</span><span class="c12 c0">. BEQ, in fact, actually branches if the result of the last operation is zero. BNE branches if the result of the last operation is NOT zero. The opcodes look at the Zero processor flag. The most common usage is CMP then BEQ/BNE. CMP is actually a subtraction with register A, without </span><span class="c0">changing A.</span><span class="c12 c0">&nbsp;To make it more clear, assume that RAM $7E0019 contains the value 33:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.0b2e09ffc893ae5bff12d268f7ff73300ba7fb92"></a><a id="t.70"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; A = $33</span></p><p class="c5"><span class="c3 c0">CMP #$33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; $33-$33 = $00</span></p><p class="c5"><span class="c3 c0">BEQ Zero&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; Branch if the result is Zero</span></p><p class="c5"><span class="c3 c0">;Blah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; You can put misc. code here.</span></p><p class="c5"><span class="c3 c0">Zero:</span></p><p class="c5"><span class="c3 c0">;Blah</span></p><p class="c5"><span class="c3 c0">RTS</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c11"></span></p><p class="c5"><span class="c0">Because subtracting $33 with $33 resulted in zero, CMP automatically set the zero flag, causing BEQ to take the branch. There&rsquo;s an advantage to this fact, which is explained in the tips and tricks chapter.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">CMP also plays around with the carry flag because again, it acts like a subtraction. In above example, the carry would be set because the result is 0. If that CMP was #$32 instead, so it&rsquo;s less than #$33 inside A, it would also be set. If the CMP was #$34 instead, it would clear the carry flag.</span></p><p class="c5 c13"><span class="c11"></span></p><p class="c5"><span class="c12 c0">About JSR and JSL, and RTS and RTL:</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Imagine that </span><span class="c0">there is a JSR opcode l</span><span class="c12 c0">ocated at $8000, and there is an LDA at $8003, and RTS at $B000. A JSR instruction is 3 bytes long (JSR $xxxx). So we have this:</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">$8000 JSR $B000</span></p><p class="c5"><span class="c12 c0">$8003 LDA #$01</span></p><p class="c5"><span class="c12 c0">&hellip;</span></p><p class="c5"><span class="c12 c0">$B000 RTS</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Now, what JSR does is, pushing the next instruction&rsquo;s location - $0001 onto the stack. This means, that the value $8002 is pushed on the stack. Then JSR jumps to the specified </span><span class="c0">address</span><span class="c12 c0">. What RTS does</span><span class="c0">, is </span><span class="c12 c0">pulling </span><span class="c0">that </span><span class="c12 c0">$8002</span><span class="c0">&nbsp;from the stack and adding $0001 to it, and storing it</span><span class="c12 c0">&nbsp;</span><span class="c0">into the program counter register, causing the program to jump back to the instruction after that JSR.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">JSL and RTL work the same way, except these push and pull 24-bit addresses. </span><span class="c0">JSL pushes the long address - 1 onto the stack and jumps to the specified address, and RTL pulls the long address +1 onto the stack and jump to it.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c5"><span class="c0">The following is about BIT $XX. Remember that BIT does a logical AND without storing the resulting value anywhere. </span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">However, here is another purpose to BIT;</span><span class="c12 c0">&nbsp;</span><span class="c0">It can affect</span><span class="c12 c0">&nbsp;the </span><span class="c1">negative and overflow</span><span class="c12 c0">&nbsp;flag. The accumulator can have </span><span class="c1">any</span><span class="c12 c0">&nbsp;value. Here</span><span class="c0">&rsquo;s an example usaage of BIT:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.e5b9d950148f9f1da437dc5c2e080ddaefa80462"></a><a id="t.71"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">BIT $04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Bit test $7E0004</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">If $7E0004&rsquo;s value was $80 (1000 0000), the negative flag would be set and the overflow flag would be clear. It</span><span class="c0">&rsquo;s useful to check really fast if the value of an address is negative.</span></p><p class="c5"><span class="c12 c0">If $7E0004&rsquo;s value was $40 (0100 0000), the negative flag would be clear and the overflow flag would be set. Useful to check if bit </span><span class="c0">6 is set.</span></p><p class="c5"><span class="c12 c0">If $7E0004&rsquo;s value was $C0 (1100 0000), the negative flag would be set and the overflow flag would be set.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c0">Coincidentally enough, the bits for negative (bit 7) and overflow (bit 6) correspond to the bits in the processor flag register: </span><span class="c11">nv</span><span class="c0">mxdizc</span><span class="c0">.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">When you are performing a BIT operation on a RAM address, the N and V flags will be set or cleared, </span><span class="c1">regardless</span><span class="c12 c0">&nbsp;of the value in the accumulator. The zero flag depends on the accumulator&rsquo;s value and the RAM address&rsquo; value. So, BIT with a RAM address does both AND, and a</span><span class="c0">n inevitable </span><span class="c12 c0">check of bits 7 and 6</span><span class="c0">&nbsp;of the RAM address.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><hr style="page-break-before:always;display:none;"><h4 class="c22 c43" id="h.7wuxy5zauavi"><span class="c18 c11">Chapter 23: In-depth look into Processor Flags</span><span class="c0 c18">&nbsp;</span><span class="c15 c0">&nbsp;Important</span></h4><p class="c5"><span class="c12 c0">Remember chapter 15, where </span><span class="c0">the </span><span class="c12 c0">use of SEP and REP has been explained? Those opcodes affect the processor flags. There are 2 different</span><span class="c0">&nbsp;modes</span><span class="c12 c0">&nbsp;of processor flags: Flags in Native mode and flags in Emulation mode (XCE). We will focus on the native mode</span><span class="c0">. The flags</span><span class="c12 c0">&nbsp;go like the following: </span><span class="c1">NVMXDIZC</span><span class="c12 c0">. These are the flags for the </span><span class="c1">native</span><span class="c12 c0">&nbsp;mode:</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">The N flag:</span></p><p class="c5"><span class="c12 c0">It is the </span><span class="c1">negative</span><span class="c12 c0">&nbsp;flag. It will get set to 1 when the last operation&rsquo;s value is between $80-$FF.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">The V flag:</span></p><p class="c5"><span class="c12 c0">Only four opcodes can affect the V flag, excluding REP, SEP and PLP. Those four opcodes are: CLV, ADC, SBC and BIT. See their description to learn when they set/clear the flag. It doesn&rsquo;t do really anything fancy</span><span class="c0">. You can use branches looking at the V flag and that&rsquo;s about it.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">The M flag:</span></p><p class="c5"><span class="c12 c0">This flag affects the register width of the A register. It stands for</span><span class="c1">&nbsp;Memory/Accumulator select</span><span class="c12 c0">. When it is set to 1, A = 8-bit. When it is set to 0, A = 16-bit.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">The X flag:</span></p><p class="c5"><span class="c12 c0">This flag affects the register width of the X </span><span class="c49 c0 c29">and</span><span class="c12 c0">&nbsp;Y register. It stands for</span><span class="c1">&nbsp;Index Register select</span><span class="c12 c0">. When it is set to 1, X and Y = 8-bit. When it is set to 0, X and Y = 16-bit.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">The D flag:</span></p><p class="c5"><span class="c12 c0">Only two opcodes can affect the D flag, with the exception of REP, SEP and PLP:</span></p><p class="c5"><span class="c12 c0">SED and CLD.</span><span class="c0">&nbsp;The decimal mode won&rsquo;t be covered in this tutorial, as it&rsquo;s </span><span class="c11">rarely</span><span class="c0">&nbsp;used and incorrectly emulated in most emulators.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">The I flag:</span></p><p class="c5"><span class="c12 c0">This is the </span><span class="c1">IRQ disable</span><span class="c12 c0">&nbsp;flag. When it is set to 1, IRQ will be disabled. Otherwise it will not be disabled (of course).</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">The Z flag:</span></p><p class="c5"><span class="c12 c0">This is the </span><span class="c1">zero</span><span class="c12 c0">&nbsp;flag. When the result of any operation is zero ($00), this flag will be set.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">The C flag:</span></p><p class="c5"><span class="c12 c0">This is the </span><span class="c1">carry</span><span class="c12 c0">&nbsp;flag. This flag is </span><span class="c36 c32 c0">set</span><span class="c12 c0">&nbsp;on unsigned overflow for ADC ($00 roll over to $FF) or when underflow for SBC does not happen</span><hr style="page-break-before:always;display:none;"></p><h4 class="c22" id="h.do7k5a6dexr"><span class="c0 c18">Chapter 24: In-depth look into Addressing modes</span></h4><p class="c5"><span class="c0">Chapter 5 covered basic addressing modes. However, t</span><span class="c12 c0">here are MUCH more </span><span class="c0">than that</span><span class="c12 c0">. In this chapter</span><span class="c0">&nbsp;all of them will be covered</span><span class="c12 c0">&nbsp;as detailed as possible. Keep in mind that only, and </span><span class="c1">only</span><span class="c12 c0">&nbsp;the A register can pull off the ( ) and [ ] stuff </span><span class="c0">covered in this chapter</span><span class="c12 c0">. Remember that indirect (long) addresses are little-endian too!</span><span class="c0">&nbsp;</span><span class="c12 c0">Keep in mind that register widths does </span><span class="c1">not</span><span class="c12 c0">&nbsp;affect the way the indirect addresses</span><span class="c0">&nbsp;are handled.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">Direct Indirect, </span><span class="c11 c24">($XX)</span><span class="c1">:</span><span class="c12 c0">&nbsp;Direct stands for Direct Page, Indirect stands for&hellip; indirect. A ( ) covering the parameter means that the address is 16-bit indirect. Here is an example of how an indirect address works in this case:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.23bb2051f25bf9ff1df3e8a613065d34805c3ea6"></a><a id="t.72"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA ($00)</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Assume that the values in $7E0000 + $7E0001 are $8900. You might think that LDA ($00) loads #$8900 into A. </span><span class="c0">However</span><span class="c12 c0">, it </span><span class="c0">doesn&rsquo;t work that way</span><span class="c12 c0">. It loads the value </span><span class="c1">in address $8900</span><span class="c12 c0">&nbsp;into A. Why is the address 16-bit? Because the ( ). The bank of the indirect address depends on the data bank register. Eventually, the opcode gets </span><span class="c0">executed </span><span class="c12 c0">as if it were LDA $8900.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">Direct Indexed with X Indirect, </span><span class="c24 c0">($XX,x)</span><span class="c1">:</span><span class="c12 c0">&nbsp;Same concept as Direct Indirect, except the address you specify in the opcode is indexed with the X register. Example:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.ced94851fb96a51a1688c8868b582cc449d48d9f"></a><a id="t.73"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">;X = $02</span></p><p class="c5"><span class="c3 c0">LDA ($00,x)</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">The </span><span class="c0">v</span><span class="c12 c0">alues in $7E0000 + $7E0001 are $8900.</span></p><p class="c5"><span class="c12 c0">The values in $7E0002 + $7E0003 are $9337.</span></p><p class="c5"><span class="c12 c0">Thanks to X, the opcode is read as LDA ($02), which loads the value in $9337.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">Direct Indirect Indexed with Y, </span><span class="c24 c0">($XX),y</span><span class="c1">: </span><span class="c12 c0">Same concept as Direct Indirect, but the indirect value is indexed with Y. Example:</span></p><p class="c13"><span class="c10 c0"></span></p><a id="t.4ea285da6f110699c0ec2848be42cac5d9cc254b"></a><a id="t.74"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">;Y = $05</span></p><p class="c5"><span class="c3 c0">LDA ($00),y</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">The values in $7E0000 + $7E0001 are $8900.</span></p><p class="c5"><span class="c12 c0">Thanks to the Y index, the loaded address is $8905. So this instruction loads the value in the </span><span class="c0">absolute address </span><span class="c12 c0">$8905.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">Absolute Indirect, </span><span class="c24 c0">($XXXX)</span><span class="c1">:</span><span class="c12 c0">&nbsp;Same concept as Direct Indirect, except the RAM address you specify in the opcode has 4 digits instead of 2.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">Absolute Indexed with X Indirect,</span><span class="c24 c0">&nbsp;($XXXX, x)</span><span class="c1">: </span><span class="c12 c0">Same concept as Direct Indexed with X Indirect, except the RAM address you specify in the opcode has 4 digits instead of 2.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5 c13"><span class="c11"></span></p><hr style="page-break-before:always;display:none;"><p class="c5 c13"><span class="c11"></span></p><p class="c5"><span class="c1">Direct Indirect Long, </span><span class="c24 c0">[$XX]</span><span class="c1">: </span><span class="c12 c0">Same concept as Direct Indirect. But those [ ] mean that the indirect address is 24-bits long. Here is an example of how [$XX] works:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.91e77aae7bdc9ae38afdb0793b498f6d2184c719"></a><a id="t.75"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA [$00]</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Assume that the values in $7E0000 + $7E0001 + $7E0002 are $028900. This basically loads the value from $028900 into A.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">Direct Indirect Indexed Long with Y, </span><span class="c24 c0">[$XX],y</span><span class="c1">:</span><span class="c12 c0">&nbsp;Same concept as Direct Indirect Indexed with Y, except the indirect address is 24-bits.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">Direct Indexed with X, </span><span class="c24 c0">$XX,x</span><span class="c1">:</span><span class="c12 c0">&nbsp;The address is indexed with X. The address is from the direct page</span><span class="c0">.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">Direct Indexed with Y, </span><span class="c24 c0">$XX,y</span><span class="c1">: </span><span class="c12 c0">Same as above, except this one is indexed with Y.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">Absolute Indexed with X, </span><span class="c24 c0">$XXXX,x</span><span class="c1">: </span><span class="c12 c0">Same as Direct Indexed with X, except the address specified here is 16-bit.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">Absolute Indexed with Y, </span><span class="c24 c0">$XXXX,y</span><span class="c1">: </span><span class="c12 c0">Same as above, except this one is indexed with Y.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">Absolute Long Indexed with X, </span><span class="c24 c0">$XXXXXX,x</span><span class="c1">: </span><span class="c12 c0">Same as Absolute/Direct Indexed with X, except this one&rsquo;s address must be 24-bits. No, there is no Absolute Long Indexed with Y. It does not exist.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c0">Actually, there</span><span class="c12 c0">&nbsp;is </span><span class="c0">one more </span><span class="c12 c0">index&hellip; The stack pointer.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">Stack Relative, </span><span class="c24 c0">$</span><span class="c55 c0">SR</span><span class="c24 c0">,s</span><span class="c1">:</span><span class="c12 c0">&nbsp;It&rsquo;s actually read as $Stack Relative,s. Not $</span><span class="c0">Direct Page</span><span class="c12 c0">,s. The $XX doesn&rsquo;t really have a meaning except the stack pointer &lsquo;position&rsquo;. We will work with LDA here to keep things simple. </span><span class="c0">Simply put:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.cfcc1c097af4f37572c3cb760acb3b65a6cc0f33"></a><a id="t.76"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $00,s ;Loads the value in the current free slot in the stack, into A.</span></p><p class="c5"><span class="c3 c0">LDA $01,s ;Loads the last pushed value into A.</span></p><p class="c5"><span class="c3 c0">LDA $02,s ;Loads the second last pushed value into A.</span></p><p class="c5"><span class="c3 c0">LDA $03,s ;&hellip;</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">You see, the s </span><span class="c0">means</span><span class="c12 c0">&nbsp;</span><span class="c0">&ldquo;</span><span class="c12 c0">indexed with the stack pointer</span><span class="c0">&rdquo;</span><span class="c12 c0">. And since the stack pointer keeps altering as values get pushed and pulled, it is a bit tricky to use.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5 c13"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c1">Stack Relative Indirect Indexed with Y,</span><span class="c24 c0">&nbsp;($SR,s),y</span><span class="c1">:</span><span class="c12 c0">&nbsp;This is one of the rarely used addressing modes. </span><span class="c0">It is hard to explain, so you&rsquo;ll have to do with an explanation</span><span class="c12 c0">:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.515c277fc85d7dde387a4ff8db17701d827e4c95"></a><a id="t.77"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">;Y = $03</span></p><p class="c5"><span class="c3 c0">;s = $01FD</span></p><p class="c5"><span class="c3 c0">;$7E01FE = $0100</span></p><p class="c5"><span class="c3 c0">LDA ($01,s),y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&rarr; LDA ($01FE),y &rarr; LDA $0100,y &rarr; LDA $0103</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c1"></span></p><p class="c5"><span class="c12 c0">Of course, direct indirect addressing mode () will behave like an absolute addressing mode. This means the bank is determined by the data bank register.</span></p><hr style="page-break-before:always;display:none;"><p class="c5 c13"><span class="c0"></span></p><h4 class="c22" id="h.31evv0aoa2ig"><span class="c0 c18">Chapter 25: Indirect pointers to routines</span></h4><p class="c5"><span class="c0">The previous chapter discussed addressing modes which can read indirect values</span><span class="c12 c0">. This chapter is dedicated to indirect pointers</span><span class="c0">&nbsp;used in conjunction with JSR.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c0">JSR can have the following addressing mode: </span><span class="c1">JSR ($addr,x)</span><span class="c11">. </span><span class="c12 c0">If you want to execute a routine depending on a RAM address&rsquo; value, you can avoid a massive amount of comparisons by making use of this opcode. Basically you have a pointer table:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.5efbaa2d6594d028f5a116e815ef597dc5a11451"></a><a id="t.78"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">Pointers:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dw Label1</span></p><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dw Label2</span></p><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dw Label3</span></p><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dw Label4</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c1"></span></p><p class="c5"><span class="c12 c0">These are just example pointers</span><span class="c0">. They generally look like that; a list of labels</span><span class="c12 c0">. To access the pointer tables with a JSR ($addr,x), you need </span><span class="c0">write code similar to the following:</span></p><p class="c5 c13"><span class="c44 c0 c19"></span></p><a id="t.fd0e9a1a00b5bdfa662199fbc0c43472dd59f3f8"></a><a id="t.79"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;(example RAM address)</span></p><p class="c5"><span class="c3 c0">ASL A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;value*2</span></p><p class="c5"><span class="c3 c0">TAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;To index</span></p><p class="c5"><span class="c3 c0">JSR (Pointers,x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Execute pointers.</span></p><p class="c5"><span class="c3 c0">RTS</span></p><p class="c5 c13"><span class="c3 c0"></span></p><p class="c5"><span class="c3 c0">Label1:</span></p><p class="c5"><span class="c3 c0">LDA #$01</span></p><p class="c5"><span class="c3 c0">STA $09</span></p><p class="c5"><span class="c3 c0">RTS</span></p><p class="c5 c13"><span class="c3 c0"></span></p><p class="c5"><span class="c3 c0">Label2:</span></p><p class="c5"><span class="c3 c0">LDA #$02</span></p><p class="c5"><span class="c3 c0">STA $09</span></p><p class="c5"><span class="c3 c0">RTS</span></p><p class="c5 c13"><span class="c3 c0"></span></p><p class="c5"><span class="c3 c0">Label3:</span></p><p class="c5"><span class="c3 c0">LDA #$03</span></p><p class="c5"><span class="c3 c0">STA $99</span></p><p class="c5"><span class="c3 c0">RTS</span></p><p class="c5 c13"><span class="c3 c0"></span></p><p class="c5"><span class="c3 c0">Label4:</span></p><p class="c5"><span class="c3 c0">LDA #$55</span></p><p class="c5"><span class="c3 c0">STA $69</span></p><p class="c5"><span class="c10 c0">RTS</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c12 c0">Basically, ASL A and TAX serve as an index to the pointer table. ASL A multiplies the loaded value by 2, so </span><span class="c0">the code</span><span class="c12 c0">&nbsp;can index the table properly (</span><span class="c0">&ldquo;dw&rdquo; means that it&rsquo;s a word value, in other words,</span><span class="c12 c0">&nbsp;2 bytes). TAX transfers A to X to use as an index. So if $00 </span><span class="c0">had the value $0</span><span class="c12 c0">1, register X would be $02 because of the multiplication. As an index to the pointers table above, it would index at dw </span><span class="c0">Label2</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5 c13"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">In short</span><span class="c12 c0">:</span></p><p class="c5"><span class="c12 c0">When $7E0000 has the value $00, the JSR will execute </span><span class="c0">code in </span><span class="c12 c0">&nbsp;</span><span class="c0">Label1 </span><span class="c12 c0">in the current bank.</span></p><p class="c5"><span class="c12 c0">When $7E0000 has the value $01, the JSR will execute </span><span class="c0">code in &nbsp;Label2</span><span class="c12 c0">&nbsp;in the current bank.</span></p><p class="c5"><span class="c12 c0">When $7E0000 has the value $02, the JSR will execute </span><span class="c0">code in &nbsp;Label3</span><span class="c12 c0">&nbsp;in the current bank.</span></p><p class="c5"><span class="c12 c0">When $7E0000 has the value $03, the JSR will execute </span><span class="c0">code in &nbsp;Label4</span><span class="c12 c0">&nbsp;in the current bank.</span></p><hr style="page-break-before:always;display:none;"><h4 class="c22" id="h.ojb6kziwvwly"><span class="c18 c11">Chapter 2</span><span class="c0 c18">6</span><span class="c18 c11">: Machine Cycles</span></h4><p class=""><span class="c0">T</span><span class="c0">he 65c816 processes the opcodes so the processor actually does stuff. The time it takes to execute the instructions is called &ldquo;Machine Cycles&rdquo;. The less machine cycles, the </span><span class="c0">less slowdown the game suffers from</span><span class="c0">. To avoid slowdown, you need to </span><span class="c0">write </span><span class="c11">efficient cod</span><span class="c11">e</span><span class="c0">. Here is an example:</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0 c29">Inefficient:</span></p><p class="c13"><span class="c10 c0"></span></p><a id="t.9c067f0fdd3b64d450b7e11138e08abd8a59b894"></a><a id="t.80"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;2 cycles</span></p><p class="c5"><span class="c3 c0">STA $7E0000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;5 cycles</span></p><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;= 7 cycles</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">To make this code more efficient, you can reduce the 2</span><span class="c0 c71">nd</span><span class="c0">&nbsp;instruction&rsquo;s size to direct page instead of long address:</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0 c29">Efficient:</span></p><p class="c13"><span class="c10 c0"></span></p><a id="t.048bb92f95ded7a831d172f2b1e445a417990958"></a><a id="t.81"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA #$00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;2 cycles</span></p><p class="c5"><span class="c3 c0">STA $00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;3 cycles</span></p><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;= 5 cycles</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">You can even make this a single instruction:</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0 c29">Extremely efficient:</span></p><p class="c13"><span class="c0"></span></p><a id="t.443d20f61eefd4595eaad97d3d745e6df70fe24c"></a><a id="t.82"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">STZ $00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;3 cycles</span></p><p class="c5"><span class="c10 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;= 3 cycles</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">You don&rsquo;t need to know how long a machine cycles takes &lsquo;in real life&rsquo;. Just </span><span class="c0">try to keep them at a minimum, but for the sake of learning ASM if you think STA $7E0000 is more simple compared to STZ $00, so be it.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c11">Please see the &ldquo;Useful links&rdquo; chapter to find the list of opcodes and their machine cycles.</span></p><hr style="page-break-before:always;display:none;"><h4 class="c22" id="h.ujr33qj61ygq"><span class="c0 c18">Chapter 27: Useless opcodes</span></h4><p class="c5"><span class="c12 c0">There are 3 useless opcodes in total, which you normally will never</span><span class="c0">&nbsp;have to use</span><span class="c12 c0">:</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c36 c32 c0">STP</span><span class="c12 c0">: Stop the clock.</span></p><p class="c5"><span class="c12 c0">It will stall the SNES, until you hit reset. It is like a force crash, but this freezes the game instead of crashing it. One of its only possible uses is to make the user </span><span class="c0">soft- or hard-reset the game</span><span class="c12 c0">. It also does lower the power consumption </span><span class="c0">of the SNES</span><span class="c12 c0">, if the couple of cents it&#39;ll shave off your power bill means that much to you. Thanks smkdan for the final piece of information.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c36 c32 c0">BRK #$XX</span><span class="c12 c0">: Software Break:</span></p><p class="c5"><span class="c12 c0">Break pushes </span><span class="c0">a bunch of stuff onto the stack</span><span class="c12 c0">, then automatically jumps to vector $FFE6 in the ROM. It is more of a debugging thing, probably no game uses it. Here is the stuff it </span><span class="c0">pushes </span><span class="c12 c0">i</span><span class="c0">n order</span><span class="c12 c0">:</span></p><p class="c5"><span class="c0">&nbsp; &nbsp;</span><span class="c12 c0">* Push the 24-bit address of the </span><span class="c0">instruction after BRK #$xx onto the stack.</span></p><p class="c5"><span class="c0">&nbsp; &nbsp;* Push the processor flags onto the stack (as one byte).</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">Furthermore (in no particular order):</span></p><p class="c5"><span class="c0">&nbsp; &nbsp;</span><span class="c12 c0">* The interrupt disable flag is set.</span></p><p class="c5"><span class="c0">&nbsp; &nbsp;</span><span class="c12 c0">* The decimal mode flag is cleared.</span></p><p class="c5"><span class="c0">&nbsp; &nbsp;</span><span class="c12 c0">* The program bank register is cleared to zero.</span></p><p class="c5"><span class="c0">&nbsp; &nbsp;</span><span class="c12 c0">* The program counter is loaded from the break vector at $FFE6-$FFE7.</span></p><p class="c13"><span class="c0"></span></p><a id="t.d2b25b46ad24f4f8c85b7b51535f9ff7e73b8928"></a><a id="t.83"></a><table class="c16"><tbody><tr class="c6"><td class="c41" colspan="1" rowspan="1"><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 161.00px; height: 17.00px;"><img alt="" src="images/image00.png" style="width: 161.00px; height: 17.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c6"><td class="c27" colspan="1" rowspan="1"><p class="c5"><span class="c0 c57">Useless to most, BRK makes debuggers snap (if the emulators are made properly), so they </span><span class="c11 c57">can</span><span class="c45 c0">&nbsp;be useful for that. You could also program the break vector at $FFE6-$FFE7 to do meaningful things when the program crashes. In fact, on SMWCentral, p4plus2 released a patch which does exactly this; it shows debug information about the crash. It&rsquo;s called &ldquo;BRK exception handler&rdquo;.</span></p></td></tr></tbody></table><p class="c13"><span class="c0"></span></p><p class="c5"><span class="c0">The parameter is not used for anything in particular, but if you write a meaningful &lsquo;catch&rsquo; to the BRK, you could probably read what the value of the BRK was supposed to be, and do certain things depending on the value.</span></p><p class="c5 c13"><span class="c23 c0 c62"></span></p><p class="c5"><span class="c36 c32 c0">COP #$XX</span><span class="c12 c0">: Coprocessor Empowerment:</span></p><p class="c5"><span class="c12 c0">This opcode causes a software interrupt, </span><span class="c0">pushes a bunch of stuff onto the stack, </span><span class="c12 c0">and the program counter is loaded from the COP vector at $FFF4-$FFF5. It does the following (in native mode):</span></p><p class=""><span class="c0">&nbsp; &nbsp;* Push the 24-bit address of the instruction after COP #$xx onto the stack.</span></p><p class=""><span class="c0">&nbsp; &nbsp;* Push the processor flags onto the stack (as one byte).</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c0">Furthermore:</span></p><p class=""><span class="c0">&nbsp; &nbsp;* The interrupt status flag is set.</span></p><p class=""><span class="c0">&nbsp; &nbsp;* The program bank register is cleared to zero.</span></p><p class=""><span class="c0">&nbsp; &nbsp;* The PC is loaded with the COP hardware vector.</span></p><p class=""><span class="c0">&nbsp; &nbsp;* The decimal flag is cleared after COP is executed.</span></p><p class="c13"><span class="c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c13"><span class="c0"></span></p><h4 class="c22" id="h.k5grc6lsip6i"><span class="c18 c11">Chapter 2</span><span class="c0 c18">8</span><span class="c18 c11">: Tips and tricks</span></h4><p class="c5"><span class="c0">This chapter features some tips and tricks which can be done with opcodes.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c40 c11">Tip 1: Amount of bytes used by an instruction</span></p><p class="c5"><span class="c12 c0">Each opcode is 1 byte. Then the byte is followed by a 0-3 bytes parameter (depending on the opcode and addressing mode). This means that the maximum amount of bytes an instruction in SNES can use, is four bytes. Here is a very small example on how LDA&rsquo;s bytes look like:</span></p><p class="c5 c13"><span class="c44 c0 c48 c19"></span></p><a id="t.9507f2ccf1219a3481e319a7a4847f9f3c7eb159"></a><a id="t.84"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c44 c0 c48 c19">LDA</span><span class="c44 c0 c19">&nbsp;</span><span class="c44 c0 c57 c19">#$</span><span class="c0 c19 c42">00</span><span class="c44 c0 c19">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c44 c0 c57 c19">;</span><span class="c44 c0 c48 c19">A9</span><span class="c44 c0 c19">&nbsp;</span><span class="c35 c0 c19">00</span></p><p class="c5"><span class="c44 c0 c48 c19">LDA</span><span class="c44 c0 c19">&nbsp;</span><span class="c44 c0 c57 c19">#$</span><span class="c42 c0 c19">00</span><span class="c28 c0 c19">11</span><span class="c44 c0 c19">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c44 c0 c57 c19">;</span><span class="c44 c0 c48 c19">A9</span><span class="c44 c0 c19">&nbsp;</span><span class="c28 c0 c19">11</span><span class="c0 c19 c35">&nbsp;00</span></p><p class="c5"><span class="c44 c0 c48 c19">LDA</span><span class="c44 c0 c19">&nbsp;</span><span class="c44 c0 c57 c19">$</span><span class="c42 c0 c19">00</span><span class="c44 c0 c19">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c44 c0 c19 c87">;</span><span class="c44 c0 c19 c48">A5</span><span class="c35 c0 c19">&nbsp;00</span></p><p class="c5"><span class="c44 c0 c48 c19">LDA</span><span class="c44 c0 c19">&nbsp;</span><span class="c44 c0 c57 c19">$</span><span class="c42 c0 c19">00</span><span class="c28 c0 c19">11</span><span class="c44 c0 c19">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c44 c0 c57 c19">;</span><span class="c44 c0 c48 c19">AD</span><span class="c44 c0 c19">&nbsp;</span><span class="c0 c19 c28">11</span><span class="c44 c0 c19">&nbsp;</span><span class="c35 c0 c19">00</span></p><p class="c5"><span class="c44 c0 c48 c19">LDA</span><span class="c0 c19 c44">&nbsp;</span><span class="c44 c0 c57 c19">$</span><span class="c42 c0 c19">00</span><span class="c28 c0 c19">11</span><span class="c52 c44 c0 c19">22</span><span class="c44 c0 c19">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c44 c0 c57 c19">;</span><span class="c44 c0 c48 c19">AF</span><span class="c44 c0 c19">&nbsp;</span><span class="c44 c0 c19 c52">22</span><span class="c28 c0 c19">&nbsp;11</span><span class="c44 c0 c19">&nbsp;</span><span class="c42 c0 c19">00</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c0 c46"></span></p><p class="c5"><span class="c0">There is a way to know how long an opcode is</span><span class="c12 c0">?</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">An instruction </span><span class="c1">without</span><span class="c12 c0">&nbsp;a hexadecimal parameter is only 1 byte, like INC A or TAX. An instruction with an 8-bit parameter is 2 bytes, like LDA #$00. An instruction with a 16-bit parameter is 3 bytes, like LDA $0000. An instruction with a 24-bit parameter is 4 bytes, like LDA $000000. It doesn&rsquo;t matter if the addressing mode is indexed, direct indirect or something else. It all depends on the length of the </span><span class="c1">$-value</span><span class="c12 c0">. </span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c40 c11">Tip 2: Pseudo 16-bit math (ADC &amp; SBC)</span></p><p class="c5"><span class="c0">It is possible to perform 16-bit math without actually switching to 16-bit mode. </span><span class="c12 c0">This is actually quite useful</span><span class="c0">&nbsp;in cases where the two involved numbers are not adjacent to each other. Here is an example of pseudo 16-bit math</span><span class="c12 c0">:</span></p><p class="c5 c13"><span class="c0 c29"></span></p><a id="t.3e14338e660a3725c35de826fcb4c57126c48025"></a><a id="t.85"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Low byte of some counter. This loads its value, $F0.</span></p><p class="c5"><span class="c3 c0">CLC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Clear Carry flag for addition. C = 0</span></p><p class="c5"><span class="c3 c0">ADC #$20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;A = $10 , C = 1 because the result went over $FF</span></p><p class="c5"><span class="c3 c0">STA $00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;$7E0000 = $10</span></p><p class="c5"><span class="c3 c0">LDA $10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;High byte of some counter. This loads its value.</span></p><p class="c5"><span class="c3 c0">ADC #$00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Add #$00 to A. BUT because C = 1, this adds $01 to A</span></p><p class="c5"><span class="c3 c0">STA $10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Store $01 into $7E0010.</span></p><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Results:</span></p><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;$7E0000 = $10</span></p><p class="c5"><span class="c10 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;$7E0010 = $01. In other words: $0110</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c0 c29 c49"></span></p><p class="c5"><span class="c12 c0">You remember how the carry flag gets set when the addition wraps from $FF-$00? </span><span class="c0">This here is a practical example</span><span class="c12 c0">&nbsp;This code increases the &rsquo;16-bit counter&rsquo; by $20, while the counter&rsquo;s value was $F0. This resulted in $0110, in 2 </span><span class="c1">separate non-adjacent </span><span class="c12 c0">RAM addresses.</span></p><p class="c5 c13"><span class="c0"></span></p><p class="c5"><span class="c0">You can do the same thing with SBC. Do SEC and SBC with one address, and SBC #$00 with another.</span><hr style="page-break-before:always;display:none;"></p><p class="c5"><span class="c11 c80">T</span><span class="c40 c11">ip 3: Copying tables to RAM</span><span class="c80 c11">&nbsp;(</span><span class="c40 c11">Looping)</span></p><p class="c5"><span class="c12 c0">What if you want to copy a table to another location, and you don&rsquo;t feel like using MVP/MVN for some reason? A massive amount of LDA STA isn&rsquo;t going to do it since it will slowdown the game (likely), waste space (definitely), AND waste YOUR time coding it (obviously). So for this, we will use a </span><span class="c1">loop</span><span class="c12 c0">. I use the X register for this but you can use the Y register too. The X register holds the amount of loops the code will do, while the A register will hold the values to copy to another location:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.9be2dec66e4e381aad8460e38de2bb48dd5534dd"></a><a id="t.86"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">PHX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Back-up the value in X, just in case</span></p><p class="c5"><span class="c3 c0">LDX #$05&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Amount of bytes to transfer</span></p><p class="c5"><span class="c3 c0">Loop: LDA Table,x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Loads the value from the table</span></p><p class="c5"><span class="c3 c0">STA $0100,x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Store into RAM address $0105 till $0100.</span></p><p class="c5"><span class="c3 c0">DEX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Decrease X</span></p><p class="c5"><span class="c3 c0">BPL Loop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;If the last operation results in </span></p><p class="c5"><span class="c3 c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;a plus value ($00-$7F), keep looping</span></p><p class="c5"><span class="c3 c0">PLX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Restore X</span></p><p class="c5"><span class="c3 c0">RTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Return from whatever routine this is.</span></p><p class="c5 c13"><span class="c3 c0"></span></p><p class="c5"><span class="c3 c0">Table: db $01,$02,$03,$04,$05,$06&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Table with random values.</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">This code takes the values in the table, and copies them to RAM addresses $7E0100-$7E0105. But the first value is put in $7E0105, and the last in $7E0100. Why? Because the index starts with $05 (LDX #$05). Don&rsquo;t worry though, you don&rsquo;t have to reverse the table since all the bytes will be put in the RAM in order. We use BPL instead of CMP BNE, because BPL branches if the value is between $00-$7F. X starts at $05 and decreases. If X is $00, and we use DEX, X will become $FF, which is a negative number. This allows us to break the loop. Keep in mind that the code works with loop counts up to value $7F. If X initially exceeds $7F, the loop will immediately break after transferring a whopping amount of 1 byte!</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Now if the table is MUCH MUCH bigger, you might want to use MVP/MVN, or </span><span class="c1">DMA </span><span class="c12 c0">(</span><span class="c30 c0">&larr;</span><span class="c12 c0">&nbsp;recommended) for efficient coding. If the index </span><span class="c1">has</span><span class="c12 c0">&nbsp;to be over $7F, you can use 16-bit indexes (REP #$10/SEP #$10). The limit will be $7FFF then.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c11 c40">Tip 4: Increasing/Decreasing the index registers by a huge amount</span></p><p class="c5"><span class="c12 c0">Increasing and decreasing A by a certain amount is easy because of ADC/SBC and all. However, such instructions aren&rsquo;t directly meant to be used for X and Y. If you want to increase/decrease X/Y by a small amount, you&rsquo;d use INX/DEX/INY/DEY. If you want to increase X/Y by a great amount, you&rsquo;d do the following:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.f6014c3de1e7fe6ffc49709847b6c63913587a86"></a><a id="t.87"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">TXA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Transfer X to A. A = X</span></p><p class="c5"><span class="c3 c0">CLC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;\</span></p><p class="c5"><span class="c3 c0">ADC #$42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;/Add #$42 to X</span></p><p class="c5"><span class="c3 c0">TAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Transfer A to X. X has increased by #$42</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">As you can see, you transfer X to A, add #$42 to it, and transfer A back to X. Same example could be applied to the Y equivalent (TYA TAY). It requires very little effort to do this, and is definitely better than a huge amount of INX instead. Also, if you want to decrease by a huge value, you&rsquo;d use SEC and SBC instead just like the basics.</span></p><p class="c5"><span class="c40 c11">Tip 5: </span><span class="c80 c11">Unlimited </span><span class="c40 c11">branching reach</span></p><p class="c5"><span class="c12 c0">In some cases, you&rsquo;ll have to branch much further than -12</span><span class="c0">8</span><span class="c12 c0">/12</span><span class="c0">7</span><span class="c12 c0">&nbsp;bytes. The SNES branch opcodes do not support this (except BRL, but it isn&rsquo;t conditional). However, with the smart use of JML and the branch opcodes, you can easily overcome this problem. Imagine the following scenario:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.1c3d2bcf7b706916100e1c9218952193d29a7975"></a><a id="t.88"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $00</span></p><p class="c5"><span class="c3 c0">CMP #$05</span></p><p class="c5"><span class="c3 c0">BEQ Forward</span></p><p class="c5"><span class="c3 c0">;*about 130 lines of code*</span></p><p class="c5"><span class="c3 c0">Forward:</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c1"></span></p><p class="c5"><span class="c12 c0">130 lines of code definitely would exceed 128 bytes (since we&rsquo;re branching forward). While trying to assemble this, the assembler will throw an error at your face of course. The code branches if $7E0000 has the value $05. So, how do we fix this? We will insert a JM</span><span class="c0">L</span><span class="c12 c0">&nbsp;in the code, and make the code reach the JM</span><span class="c0">L</span><span class="c12 c0">&nbsp;if $7E0000 has the value $05. In the end, we get this:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.4db9795c0e7834c17a5f2a3845db0fe89d4e419f"></a><a id="t.89"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $00</span></p><p class="c5"><span class="c3 c0">CMP #$05</span></p><p class="c5"><span class="c3 c0">BNE Continue &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;if $7E0000 is $05, reach the JML. If not $05, continue </span></p><p class="c5"><span class="c3 c0">JML Forward&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;No more limitations!</span></p><p class="c5"><span class="c3 c0">Continue:</span></p><p class="c5"><span class="c3 c0">;*about 130 lines of code*</span></p><p class="c5"><span class="c3 c0">Forward:</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c1"></span></p><p class="c5"><span class="c12 c0">Basically, this way we have extended our branch and can jump anywhere in the bank now! The continue label is there so we can skip the JML if we have to. This works with almost every branch opcode! For example, here&rsquo;s one with BVS/BVC:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.e3c23bf1892943721c67cafae13e43c79b3c7e47"></a><a id="t.90"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">BVC Forward</span></p><p class="c5"><span class="c3 c0">;*about 130 lines of code*</span></p><p class="c5"><span class="c3 c0">Forward:</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c1"></span></p><p class="c5"><span class="c12 c0">To</span></p><p class="c5 c13"><span class="c0"></span></p><a id="t.dcb33864fdf499a1bbab2690ea28c047162fa5c4"></a><a id="t.91"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">BVS Continue</span></p><p class="c5"><span class="c3 c0">JML Forward</span></p><p class="c5"><span class="c3 c0">Continue:</span></p><p class="c5"><span class="c3 c0">;*about 130 lines of code*</span></p><p class="c5"><span class="c10 c0">Forward:</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c1"></span></p><p class="c5"><span class="c12 c0">As you can see, I am turning the existing branch into the opposite version of it (BEQ </span><span class="c0 c30">&rarr; </span><span class="c12 c0">BNE, BVS </span><span class="c30 c0">&rarr; </span><span class="c12 c0">BVC, and so on) and add a JML after it, which gets followed by a Continue label. That&rsquo;s the basic structure of a limitless branch. Of course, if BRA gets out of range you&rsquo;d simply replace it with JMP/JML or something, since BRA doesn&rsquo;t do comparison.</span></p><hr style="page-break-before:always;display:none;"><p class="c5"><span class="c40 c11">Tip 6: Faster comparison and branching with BEQ and BNE</span></p><p class="c5"><span class="c12 c0">Faster comparison makes use of processor flags effectively, because branches actually depend on the processor</span><span class="c0">&nbsp;flags</span><span class="c12 c0">. BEQ branches if the z flag is set, BNE branches if the z flag is clear, BCC branches if the c flag is clear, etc.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Often, if the result of </span><span class="c1">any</span><span class="c12 c0">&nbsp;operation is zero ($00 or $0000), the zero flag gets set. For example, if you do LDA #$00,</span><span class="c0">&nbsp;the zero flag is set</span><span class="c12 c0">. As long as a zero gets involved in the end. How can this be useful in branching?</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Well, assume that RAM address $7E0001 contains the number $00. Then the following piece of code:</span></p><p class="c5 c13"><span class="c44 c0 c19"></span></p><a id="t.e6717b332e967566585e5a4c0472b6eaf5bc4dbe"></a><a id="t.92"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $7E0001</span></p><p class="c5"><span class="c3 c0">CMP #$00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Branch if $7E0001 is $00</span></p><p class="c5"><span class="c0 c10">BEQ Branch</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c1"></span></p><p class="c5"><span class="c12 c0">This code branches if $7E0000 has the number $00. CMP sets the zero flag here because </span></p><p class="c5"><span class="c12 c0">$00-$00 = $00 (remember, CMP does a subtraction).</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">However, the zero flag already gets set when LDA gets executed, because $7E0001 contains the number $00. There&rsquo;s no need for CMP #$00. BEQ branches if zero flag is set. So, above code can be simplified as this:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.552623bebf01a6cf8e6fc813c09a456f7c86c638"></a><a id="t.93"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $7E0001</span></p><p class="c5"><span class="c3 c0">BEQ Branch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Branch if $7E0001 is $00, and $00 ONLY</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">If you want the code to branch if $7E0001 is NOT $00, you&rsquo;d do something like this:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.648012d71c8c00266937114dbc6b2874c584a4bf"></a><a id="t.94"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $7E0001</span></p><p class="c5"><span class="c3 c0">CMP #$00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;Branch if $7E0001 is NOT $00</span></p><p class="c5"><span class="c3 c0">BNE Branch </span></p></td></tr></tbody></table><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">But this can be simplified too. If $7E0001 is NOT $00, and you perform an LDA using that address, the zero flag gets cleared. BNE branches if zero flag is cleared, so there&rsquo;s no point in CMP #$00</span><span class="c0">.</span><span class="c12 c0">&nbsp;Above code can be simplified as:</span></p><p class="c5 c13"><span class="c10 c0"></span></p><a id="t.51025e4d8f412b98fc3b1258f4a6948a99a53fda"></a><a id="t.95"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">LDA $7E0001</span></p><p class="c5"><span class="c3 c0">BNE Branch</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c1"></span></p><p class="c5"><span class="c12 c0">The code branches if $7E0001 is NOT $00</span><span class="c0">, meaning it branches when the value is between $01 and $FF.</span></p><p class="c8 c13"><span class="c12 c0"></span></p><hr style="page-break-before:always;display:none;"><p class="c5"><span class="c40 c11">Tip 7: Pseudo 16-bit math (INC &amp; DEC)</span></p><p class="c5"><span class="c12 c0">You can also perform pseudo-16 bit math with INC addr and DEC addr, using the zero flag wisely. It is useful for increments/decrements by one. Here&rsquo;s an example code:<br></span></p><a id="t.a5b02143d32530035255d632f1e41ee66c913881"></a><a id="t.96"></a><table class="c16"><tbody><tr class="c6"><td class="c37" colspan="1" rowspan="1"><p class="c5"><span class="c3 c0">INC $00</span></p><p class="c5"><span class="c3 c0">BNE NotZero</span></p><p class="c5"><span class="c3 c0">INC $01</span></p><p class="c5"><span class="c3 c0">NotZero:</span></p><p class="c5"><span class="c3 c0">;*more code*</span></p></td></tr></tbody></table><p class="c5 c13"><span class="c1"></span></p><p class="c5"><span class="c12 c0">Here, $7E0000 contains the 16-bit value $0FFF for example. Dividing it in 8-bit blocks, it would be: </span><span class="c1">$7E0000</span><span class="c12 c0">&nbsp;holds value </span><span class="c1">$FF</span><span class="c12 c0">, </span><span class="c1">$7E0001</span><span class="c12 c0">&nbsp;holds value </span><span class="c1">$0F</span><span class="c12 c0">.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">BNE Branches if </span><span class="c1">$7E0000</span><span class="c12 c0">&nbsp;doesn&rsquo;t hold </span><span class="c1">$00</span><span class="c12 c0">&nbsp;after the INC. In this case, it doesn&rsquo;t branch</span><span class="c0">.</span><span class="c12 c0">&nbsp;So:</span></p><p class="c5"><span class="c12 c0">$FF + $01 makes $00, with the zero flag clear. The branch therefore doesn&rsquo;t get taken, and INC $01 gets executed. $0F becomes $10. Final result becomes: </span><span class="c1">$7E0000</span><span class="c12 c0">&nbsp;holds value </span><span class="c1">$00</span><span class="c12 c0">, </span><span class="c1">$7E0001</span><span class="c12 c0">&nbsp;holds value </span><span class="c1">$10</span><span class="c12 c0">. In 16-bit that would be $1000!</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">If you want to do this with decreasing values, you&rsquo;d replace INC with DEC.</span></p><hr style="page-break-before:always;display:none;"><h4 class="c22" id="h.1lohk3ajdceg"><span class="c18 c11">Chapter</span><span class="c0 c18">&nbsp;29</span><span class="c18 c11">: Programming cautions</span><span class="c15 c0">&nbsp;Important</span></h4><p class="c5 c13"><span class="c86 c15 c0"></span></p><p class="c5"><span class="c12 c0">When you&rsquo;re coding, you will have to </span><span class="c0">keep an eye out on (common) mistakes.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">CAUTION #1:</span></p><p class="c5"><span class="c12 c0">Don&rsquo;t try to load an 8-bit value into AXY when AXY is in 16-bit mode</span></p><p class="c5"><span class="c60 c58 c0">Consequence(s):</span></p><p class="c5"><span class="c12 c0">The game will most-likely crash</span><span class="c0">&nbsp;by interpreting by substituting the missing 2nd half of the 16-bit parameter with the next opcode, making the next opcode&rsquo;s parameter interpret as an undesirable opcode.</span></p><p class="c5"><span class="c68 c58 c0 c48">Fixing the issue:</span></p><p class="c5"><span class="c12 c0">Either load a 16-bit value into AXY, or change AXY to 8-bit.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">CAUTION #2:</span></p><p class="c5"><span class="c12 c0">Don&rsquo;t try to load a 16-bit value into AXY when AXY is in 8-bit mode</span></p><p class="c5"><span class="c60 c58 c0">Consequence(s):</span></p><p class="c5"><span class="c12 c0">The game will most-likely crash</span><span class="c0">&nbsp;because the excess 2nd half of the 16-bit parameter is interpreted as an undesirable opcode.</span></p><p class="c5"><span class="c68 c58 c0 c48">Fixing the issue:</span></p><p class="c5"><span class="c12 c0">Either load an 8-bit value into X or Y, or change AXY to 16-bit.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">CAUTION #3:</span></p><p class="c5"><span class="c12 c0">When creating loops, don&rsquo;t make a small mistake which results in an infinite loop (a loop which doesn&rsquo;t exit).</span></p><p class="c5"><span class="c60 c58 c0">Consequence(s):</span></p><p class="c5"><span class="c12 c0">The game will lock up; the only way to exit is to hit reset.</span></p><p class="c5"><span class="c58 c0 c48 c68">Fixing the issue:</span></p><p class="c5"><span class="c12 c0">Check at the end of the loop (often a comparison) to see why it doesn&rsquo;t allow the loop to exit.</span><span class="c0">&nbsp;</span><span class="c12 c0">You might need a debugger for this.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">CAUTION #4:</span></p><p class="c5"><span class="c12 c0">Don&rsquo;t make absurdly slow loops (especially ones which run every frame). Absurdly slow meaning: loop which runs over 9000 times which executes 9999 lines of slow code.</span></p><p class="c5"><span class="c60 c58 c0">Consequence(s):</span></p><p class="c5"><span class="c12 c0">It might slow down your game which is inconvenient.</span></p><p class="c5"><span class="c68 c58 c0 c48">Fixing the issue:</span></p><p class="c5"><span class="c12 c0">Optimize the code </span><span class="c1">within</span><span class="c12 c0">&nbsp;the loop, or process the loop at such a moment that the player won&rsquo;t notice slowdown (for example: black screens).</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c1">CAUTION #5:</span></p><p class="c5"><span class="c12 c0">Make sure your code doesn&rsquo;t cross bank-boundaries ($XX:FFFF </span><span class="c30 c0">&rarr; </span><span class="c12 c0">$XX:0000) inside the ROM.</span></p><p class="c5"><span class="c58 c0 c60">Consequence(s):</span></p><p class="c5"><span class="c12 c0">The SNES would read </span><span class="c0">bogus values you will never predict, and most-likely crash.</span></p><p class="c5"><span class="c68 c58 c0 c48">Fixing the issue:</span></p><p class="c5"><span class="c12 c0">The code should remain within a bank. If it isn&rsquo;t possible, use extra code which checks for bank boundaries and reads data accordingly. Another option is making wise use of JSLs and JMLs when executable code exceeds bank boundaries.</span><hr style="page-break-before:always;display:none;"></p><p class="c5"><span class="c1">CAUTION #6:</span></p><p class="c5"><span class="c12 c0">Make sure your branch doesn&rsquo;t get </span><span class="c0">out of range.</span></p><p class="c5"><span class="c60 c58 c0">Consequence(s):</span></p><p class="c5"><span class="c12 c0">Assembler will throw an error. If it doesn&rsquo;t, then the assembler is bad, and the branch might go to the opposite direction by an unknown amount when the code is running, which will likely result in a crash/infinite loops/other unwanted effects.</span></p><p class="c5"><span class="c68 c58 c0 c48">Fixing the issue:</span></p><p class="c5"><span class="c12 c0">See programming tip #5 in previous chapter.</span></p><hr style="page-break-before:always;display:none;"><p class="c5 c13"><span class="c12 c0"></span></p><h4 class="c22" id="h.g4fcc49qji5d"><span class="c0 c18">Chapter 30: Useful links</span></h4><p class=""><span class="c0">This chapter will list a bunch of useful links for additional ASM information. They aren&rsquo;t necessarily restricted to ASM but can also include SNES hardware stuff.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c2 c0"><a class="c17" href="https://www.google.com/url?q=http://wiki.superfamicom.org/&amp;sa=D&amp;ust=1471566888795000&amp;usg=AFQjCNGOWrlMOcuKQPobslIINYDggrC9sw">http://wiki.superfamicom.org/</a></span></p><p class=""><span class="c11">Super Nintendo Development Wiki</span><span class="c0">&nbsp;- Particularly, the 65c816 reference page excels in going in-depth regarding the opcodes. It shows which processor flags each and single opcode affects. This wiki basically has everything you need in order to start developing things for the SNES.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c2 c0"><a class="c17" href="https://www.google.com/url?q=https://en.wikibooks.org/wiki/Super_NES_Programming&amp;sa=D&amp;ust=1471566888804000&amp;usg=AFQjCNFlhXZFnZ7SgXnMUcIu2oliAbHcvw">https://en.wikibooks.org/wiki/Super_NES_Programming</a></span></p><p class=""><span class="c11">Super NES Programming Wiki</span><span class="c0">&nbsp;- A website succeeded by the website above, meaning this website is kind of&hellip; outdated at this point. But I put it here anyway because it kind of helped me out with various ASM things regardless.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c2 c0"><a class="c17" href="https://www.google.com/url?q=http://media.smwcentral.net/Ersanio/SMWCstuff/Advanced%2520documentation/ASM_Workshop.htm&amp;sa=D&amp;ust=1471566888812000&amp;usg=AFQjCNE1K8kBYA-Xo-kx0bC2FPPhiuaAgw">http://media.smwcentral.net/Ersanio/SMWCstuff/Advanced%20documentation/ASM_Workshop.htm</a></span></p><p class=""><span class="c11">SMWCentral&rsquo;s IRC ASM Workshop</span><span class="c0">&nbsp;- A workshop held on SMWCentral&rsquo;s official IRC teaching various ASM things. You might want to save this file locally in case it ever gets removed for some reason.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c2 c0"><a class="c17" href="https://www.google.com/url?q=http://acmlm.kafuka.org/board/thread.php?id%3D99&amp;sa=D&amp;ust=1471566888814000&amp;usg=AFQjCNEWmauvcyv8nhBUA23264syWcn-JQ">http://acmlm.kafuka.org/board/thread.php?id=99</a></span></p><p class=""><span class="c11">Sukasa&rsquo;s ASM tutorial</span><span class="c0">&nbsp;- This is an ASM tutorial within a Super Mario World context. What&rsquo;s great about this tutorial is that it actually works with tangible things; there are examples of how to set Mario&rsquo;s powerup status. It is also very short and to the point (unlike this tutorial).</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c2 c0"><a class="c17" href="https://www.google.com/url?q=http://media.smwcentral.net/Ersanio/SMWCstuff/Advanced%2520documentation/65816REF.HLP&amp;sa=D&amp;ust=1471566888818000&amp;usg=AFQjCNHhwC3bUlI4Nk40yZuoMvflCT16vQ">http://media.smwcentral.net/Ersanio/SMWCstuff/Advanced%20documentation/65816REF.HLP</a></span></p><p class=""><span class="c11">65c816 Reference</span><span class="c0">&nbsp;- An 65c816 reference help file which shows a list of opcodes and what processor flags they affect. Might not work on the newest versions of Windows. You might want to save this file locally in case it ever gets removed for some reason. (Maybe I&rsquo;ll make a HTML version of this in the future)</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c2 c0"><a class="c17" href="https://www.google.com/url?q=http://media.smwcentral.net/Ersanio/SMWCstuff/Advanced%2520documentation/65816info.txt&amp;sa=D&amp;ust=1471566888821000&amp;usg=AFQjCNEd4NzIqI2hzPfYCjKvA_rnSpkIjQ">http://media.smwcentral.net/Ersanio/SMWCstuff/Advanced%20documentation/65816info.txt</a></span></p><p class=""><span class="c11">65c816 Primer</span><span class="c0">&nbsp;- A very technical document about the 65c816. You might want to save this file locally in case it ever gets removed for some reason.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c2 c0"><a class="c17" href="https://www.google.com/url?q=http://media.smwcentral.net/Ersanio/SMWCstuff/Advanced%2520documentation/SNES%2520Dev%2520Manual%2520(searchable%2520text%2520layer).zip&amp;sa=D&amp;ust=1471566888826000&amp;usg=AFQjCNGdWpCkJn6o3KE0MpQOx-ftOkyK6Q">http://media.smwcentral.net/Ersanio/SMWCstuff/Advanced%20documentation/SNES%20Dev%20Manual%20(searchable%20text%20layer).zip</a></span></p><p class=""><span class="c11">SNES Development Manual</span><span class="c0">&nbsp;- Nintendo&rsquo;s official SNES Development manual in 2 PDFs detailing pretty much </span><span class="c32 c0">everything</span><span class="c0">&nbsp;about the SNES and how the console works. You might want to save this file locally in case it ever gets removed for some reason.</span></p><p class="c13"><span class="c0"></span></p><p class=""><span class="c2 c0"><a class="c17" href="https://www.google.com/url?q=http://www.defence-force.org/computing/oric/coding/annexe_2/index.htm&amp;sa=D&amp;ust=1471566888830000&amp;usg=AFQjCNGgqCgbXE2tUM4iIcvqwzyY8Ttbuw">http://www.defence-force.org/computing/oric/coding/annexe_2/index.htm</a></span></p><p class=""><span class="c11">Introduction to 65c016</span><span class="c0">&nbsp;- A small page comparing the 65c816 with the 6502 (the processor used in the NES), as well as a reference of opcodes.</span></p><hr style="page-break-before:always;display:none;"><h4 class="c43 c22" id="h.94tivrmhcic3"><span class="c18 c11">Chapter</span><span class="c0 c18">&nbsp;31</span><span class="c18 c11">: Final notes</span></h4><p class="c5"><span class="c12 c0">This tutorial teaches you most of the things you should know about ASM. But to truly master ASM, there&rsquo;s only one obvious solution: practice. Only reading tutorials won&rsquo;t really help; you&rsquo;ll have to get used to ASM.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">An important part of ASM is thinking logically: at first you will be able to load and store values only, then you will advance to conditional operations. </span><span class="c0">Eventually</span><span class="c12 c0">, you will start to think logically; basically you will &lsquo;emulate ASM in your mind&rsquo; as in, imagining the SNES behaviour while coding. This is useful for writing effective code while knowing what the eventual outcome will be. </span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Another important part is</span><span class="c0">&nbsp;not being afraid to try out new opcodes. It&rsquo;s not like you can&rsquo;t undo code in your text editor.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Learning ASM takes a long time. I&rsquo;ve started learning ASM </span><span class="c1">before</span><span class="c12 c0">&nbsp;I even knew what </span><span class="c0">programming </span><span class="c12 c0">meant. SMWCentral was the place where I started to learn ASM, because that board lacked people who knew ASM at that time. People like Bio and GhettoYouth inspired me, due to their amazing Super Mario World ASM hacks.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c12 c0">Don&rsquo;t get demotivated just because it takes months or maybe years to master ASM, or because you didn&rsquo;t really learn anything from this tutorial. If you learn ASM, you will benefit from the results and eventually you will be able to hack almost any game. You will gain programming experience too. You could look into programming in general and focus on programming like me. It has been over 3 years and I still don&rsquo;t consider myself as an ASM master (yet), but I know almost everything about ASM now. The next thing waiting for me is advanced SNES development but that&rsquo;s far beyond my reach so I&rsquo;m pretty much stuck at solving SNES code and developing algorithms.</span></p><p class="c5 c13"><span class="c12 c0"></span></p><p class="c5"><span class="c0">If y</span><span class="c12 c0">ou don&rsquo;t know something, just seek help from someone or look up documents. The important part is </span><span class="c0">that you&rsquo;re willing</span><span class="c12 c0">&nbsp;to learn ASM.</span></p><hr><p class="c5"><span class="c12 c0">End of ASM tutorial.</span></p><div><p class="c5 c13 c96"><span class="c54 c0 c76"></span></p><p class="c78"><span class="c54 c0">Page </span><span class="c0 c54">&nbsp;of </span></p></div></body></html>